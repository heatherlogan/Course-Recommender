{
	"courses" : [
		{
			"Name" : "Automated Reasoning",
			"Code" : "INFR09042",
			"Summary" : "The overall aim of the course is to describe how reasoning can be modelled using computers. Its more specific aim is to provide a route into more advanced uses of theorem proving in order to solve problems in mathematics and formal verification.Major emphases are on: how knowledge can be represented using propositional, first-order and higher-order logic; how these representations can be used as the basis for reasoning, and how these reasoning processes can be guided to a successful conclusion through a variety of means ranging from fully-automated to interactive ones. Students will develop a thorough understanding of modern, interactive theorem proving via lectures, tutorials and an assignment. ",
			"Course Description" : "The course starts with an introduction to higher order logic, theorem provers and, more specifically, Isabelle/HOL. This will set the context for the rest of the course in which Isabelle will be the framework for getting hands-on experience about the application of various theoretical concepts.Through the lectures and tutorials that incorporate practical exercises the students will gain the skills needed to get started with Isabelle and progress to more complex concepts involving both representation and reasoning.The second part will look at representation/modelling of concepts in (higher order) logic in details. Axiomatic versus conservative extensions of theories will be covered and mechanisms such as Isabelle locales will be introduced and used. Recursive definitions and inductive notions will be covered too.The third part of the course will focus on fundamental notions such as unification and rewriting, within both a first and higher order context. It will look at notions such as termination and use Isabelle's simplifier as the tool for understanding many of the concepts. It will also look at the interplay between (fully) automatic and interactive proofs.The fourth part will introduce declarative/structured proofs and using the Isar language of Isabelle show how proofs resembling pencil and paper ones can be formalized.Finally the various strands will brought together through the discussion of a non-trivial case study.This may involve either formalized mathematics (e.g. looking at a geometric theory) or a formal verification example.The assignment will be a combination of basic to intermediate representation and reasoning in Isabelle (up to 40%), more advanced proof tackling one particular domain or example (up to 40%) and a final part which, if completed successfully, will clearly demonstrate that the student has a good of the challenges that advanced interactive theorem proving entails.",
			"Credits" : "10",
			"Level" : "09",
			"Year" : "3",
			"Average" : "60.15",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["I would recommend it, as long as you're prepared to sit down and spend some time making sure you know how to use Isabelle",
						  "IT'S A PAINFUL COURSE, DON'T DO IT UNLESS YOU REALLY LIKE ASSISTED THEOREM PROVING AND LOGIC",
						  "This course will be painful, if you are not interested in Logic, Math and programming. Honestly, don't take it, unless you are interested in those three. However, if you are, this is possibly the best course for you.",
						  "Work constantly on the material as its being taught and make sure you understand and try to solve all the tutorial questions. That way you will not find any problem dealing with the course. Otherwise you might struggle with it, especially with the coursework",
						  "Worth the challenge."]
		},
		{
			"Name" : "Computer Design",
			"Code" : "INFR09046",
			"Summary" : "This course provides an introduction to the fundamental concepts of the different ways computers can be analysed and designed. The course does not look at the differences between machines with different types of instruction set, nor does it cover design techniques for extracting maximum performance from computers - these aspects of computer hardware are covered in the Computer Architecture course. The issues and techniques covered in the Computer Design course are relevant to the design of all computers, regardless of their particular architecture.The course is partitioned into three sections. The short first section revises the design of combinational and sequential logic. The second section demonstrates how to analyse and design systems of the complexity of a simple CPU or I/O controller. The third section of the course covers the design of a complete computer capable of executing assembly code programs and different control strategies for performing I/O.",
			"Course Description" : "Logic Design Revision Simple combinational logic design to state machines for sequential circuits.Processor Design Data path and control. Fixed program controllers: example and design procedure. Instruction set processors: data path design, simple control, microprogrammed control. ALU design: addition, ripple carry and look ahead adders, negative numbers & subtraction; multiplication sequential multiplier, modification for 2's complement, combinational multiplier, division. Floating point numbers: addition, multiply and divide, implementations.Computer Systems Memory: Byte vs. word addressing, memory system design, error detection and correction. I/O Design: I/O controller design. Connection of I/O controllers to CPU, synchronization of I/O and CPU, polling, interrupts. Direct Memory Access, bus arbitration, DMA controller implementation. I/O processors. Synchronous and asynchronous buses. Simple performance enhancements to the basic architecture. RISC.",
			"Credits" : "20",
			"Level" : "09",
			"Year" : "3",
			"Average" : "77.63",
			"Area" : "Architecture",
			"Prerequisites" : [],
			"Feedback" : ["Content was interesting and the coursework was a great way to enhance the overall understanding of the study material. The exercise sheets and provided answers were also very helpful, since they gave an idea of potential exam questions. The lecturer is very good at explaining the content and was really helpful during labs - sometimes stayed well beyond the lab finish time to help us with the coursework. Overall, a really good course and one of the best lecturers I have had at uni so far",
						  "Excellent lecturer, very clear and explained things extremely well, both in lectures and tutorials. Interesting and engaging course."]
		},
		{
			"Name" : "Foundations of Natural Language Processing",
			"Code" : "INFR09028",
			"Summary" : "This course covers some of the linguistic and algorithmic foundations of natural language processing. It builds on the material introduced in Informatics 2A and aims to equip students for more advanced NLP courses in years 3 or 4. The course is strongly empirical, using corpus data to illustrate both core linguistic concepts and algorithms, including language modeling, part of speech tagging, syntactic processing, the syntax-semantics interface, and aspects of semantic processing. Linguistic and algorithmic content will be interleaved throughout the course.",
			"Course Description" : "1. Creating annotated corpora:* markup, annotation* evaluation measures* corpora and the web 2. Lexicon and lexical processing:* language modeling* Hidden Markov Models* part of speech tagging (e.g., for a language other than English) to illustrate HMMs* Viterbi algorithm* smoothing 3. Syntax and syntactic processing:* syntactic concepts: constituency, subcategorization, bounded and unbounded dependencies, feature representations4. Semantics and semantic processing:* compositionality, * argument structure, * word sense disambigution,  * anaphora resolution, * treebanks: argument structure, WSD (e.g., Propbank, Semcor)Relevant QAA Computing Curriculum Sections: Artificial Intelligence, Natural Language Computing",
			"Credits" : "10",
			"Level" : "09",
			"Year" : "3",
			"Average" : "81.52",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["It’s a very easy course but essential to your development as a Computer Scientist. You will understand everything even better if you also take IAML",
						  "This course is excellent, take it and enjoy it. The workload is pretty fair in my opinion and the assignments are posted well in advance. Go to the lectures, they are both useful and really engaging.",
						  "This course taught you foundations about NLP, very good introductory course.",
						  "Lectures are great, but don't teach you how to code the assignments at all. That's expected, but the lab leaders also did not help with coding very much, so unless you know Python very well already the assignments were difficult.",
						  "Take it. It’s great."]
		},
		{
			"Name" : "Introduction to Vision and Robotics",
			"Code" : "INFR09019",
			"Summary" : "Robotics and Vision applies AI techniques to the problems of making devices capable of interacting with the physical world. This includes moving around in the world (mobile robotics), moving things in the world (manipulation robotics), acquiring information by direct sensing of the world (e.g. machine vision) and, importantly, closing the loop by using sensing to control movement. Applying AI in this context poses certain problems, and sets certain limitations, which have important effects on the general software and hardware architectures. For example, a robot with legs must be able to correct detected imbalances before it falls over, and a robot which has to look left and right before crossing the road must be able to identify approaching hazards before it gets run over. These constraints become much more serious if the robot is required to carry both its own power supply and its own brain along with it. This module introduces the basic concepts and methods in these areas, and serves as an introduction to the more advanced robotics and vision modules.",
			"Course Description" : "The issues addressed will include the following: * Applications of robotics and vision; the nature of the problems to be solved; historical overview and current state of the art. * Robot actuators and sensors. Parallels to biological systems. * Robot control: Open-loop, feed-forward and feedback; PID (proportional integral differential) control. * Image formation, transduction and simple processing; thresholding, filtering and classification methods for extracting object information from an image. * Active vision and attention. * Sensors for self monitoring. * General approaches and architectures. Classical vs. behaviour-based robotics. Wider issues and implications of robot research.  The course also involves hands-on practicals in which vision and robot systems will be programmed. Relevant QAA Computing Curriculum Sections: Artificial Intelligence; Computer Vision and Image Processing",
			"Credits" : "10",
			"Level" : "09",
			"Year" : "3",
			"Average" : "63.65",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback": [" Don't. If you're unlucky enough to have signed up for this course, drop it as soon as you can. You'll do better and learn more if you jump into any other course half way through the semester.",
						 "START THE COURSEWORK EARLY!!!!",
						 "Take this course only if you have decent maths and physics",
						 "Take your time to go through the equations on the slides and make sure you understand them. It is too late to start paying attention to them once you start working on the coursework.",
						 "Focus on the Labs for this course, which are helpful for both lectures and assignment."]
		},
		{
			"Name" : "Operating Systems",
			"Code" : "INFR09047",
			"Summary" : "This course provides an introduction to the design and implementation of general purpose multi-tasking operating systems. It concentrates on the kernel aspects of such systems with the emphasis being on concepts which lead to practical implementations. Throughout the course reference is made to a number of significant actual operating systems (Linux, Windows variants etc.) to illustrate real implementations.",
			"Course Description" : "Process management*The process concept, synchronisation, mutual exclusion, semaphores and monitors. Threads. Inter-process communication.Resource Allocation*Deadlock prevention, avoidance and detection.The OS Kernel*Micro and Monolithic kernels. Multi-tasking, privilege, interrupt handling. System and user processes. System calls.Memory Management*Description of problems of allocation, protection and sharing. Virtual Physical memory mapping schemes.*Segmented paged virtual memory. Paging control, replacement algorithms; the working set model. Sharing code and data. Time ManagementFile Management*Naming and Directory schemes. Disc space allocation. File protection and access control. System security. *Various additional topics may be included from year to year. Relevant QAA Computing Curriculum Sections: Operating Systems",
			"Credits" : "20",
			"Level" : "09",
			"Year" : "3",
			"Average" : "71.63",
			"Area" : "Architecture",
			"Prerequisites" : [],
			"Feedback" : ["Go for it, both the lectures and the coursework are quite enjoyable. Make sure you read the coursework assignments while well rested. It is somewhat difficult to understand at first but once you do, the implementation is reasonably straightforward.",
						  "It's easy to follow and understand.",
						  "Quite interesting and very good lecturers!",
						  "Recommended.",
						  "Start the assignments early."]
		},
		{
			"Name" : "System Design Project",
			"Code" : "INFR09032",
			"Summary" : "The System Design Project is intended to give students practical experience of (a) building a large scale system (b) working as members of a team. The project involves applying and combining material from several courses to complete a complex design and implementation task. At the end of course each group demonstrates its implemented system and gives a formal presentation to an audience of the students, supervisors, and visitors from industry.",
			"Course Description" : "During this project students work in groups of about ten on the design and implementation of a complete system to solve some practical and useful problem. All groups perform the same task. This primarily involves software implementation but may potentially also involve hardware design and construction where this is relevant. Recent examples of projects include: an automated on-line supermarket; building webcam-based home and commercial security systems; constructing Mars and Lunar rovers controlled from an Earth-based web browser interface, etc.Each group is provided with the same facilities. These include one or more PCs dedicated to them and other equipment depending on the particular project, for instance a webcam, a Lego robot construction kit, hardware prototyping kit, diagnostic equipment etc. They also have a small amount of money to spend in any way they choose on any extra items they feel might enhance their particular design. Project management software is also available to them. Each group is assigned a mentor. The mentor's task is to advise and provide feedback on the progress of the group during the project but not to provide technical support. Consultants from amongst the academic and support staff are made available to advise on aspects of the task such as management, specific pieces of software and hardware etc. Groups meet with their mentors at least once a week. They also meet amongst themselves more frequently to plan and coordinate their activities. Towards the end of the semester, a day is set aside for groups to demonstrate their implemented system and to give a formal presentation of it to an audience of the students, mentors, and visitors from industry. Relevant QAA Computing Curriculum Sections: Computer Based Systems, Systems Analysis and Design",
			"Credits" : "20",
			"Level" : "09",
			"Year" : "3",
			"Average" : "71.09",
			"Area" : "Software Engineering",
			"Prerequisites" : [],
			"Feedback" : ["I am really sorry for you! Hope it ends well! Pray for a team with decent people!",
						  "Do not take this course. It is one of the worst-run and most stressful courses in Informatics.",
						  "Although it’s an Informatics course, be prepared to do a lot of work in terms of organization, team management, writing documentation and etc. Useful if you don't have any industry experience. However, if you have experience and it's not compulsory for you, think twice before taking this course (its loads of work)",
						  "Find good ways of dealing with stress because this course will be a lot of stress."]
		},
		{
			"Name" : "Algorithms and Data Structures",
			"Code" : "INFR10052",
			"Summary" : "The course aims to provide general techniques for the design of efficient algorithms and, in parallel, develop appropriate mathematical tools for analysing their performance. In this, it broadens and deepens the study of algorithms and data structures initiated in INF2. The focus is on algorithms, more than data structures. Along the way, problem solving skills are exercised and developed.",
			"Course Description" : "Introductory concepts. Review of CS2. Models of computation; time and space complexity; upper and lower bounds, big-O and big-Omega notation; average and worst case analysis. Divide and conquer. Matrix multiplication: Strassen's algorithm; the discrete Fourier transform (DFT), the fast Fourier transform (FFT). Expressing the runtime of a recursive algorithm as a recurrence relation; solving recurrence relations. Sorting. Quicksort and its analysis; worst-case, best-case and average-case. Data structures: Disjoint sets. The ``disjoint sets'' (union-find) abstract data type: specification and implementations as lists and trees. Union-by-rank, path-compression, etc., ``heuristics''. Applications to finding minimum spanning trees. Dynamic programming. Introduction to the technique; examples: Matrix-chain multiplication, Longest common subsequences. Graph/Network algorithms Network flow, Max-flow/min-cut theorem, Ford-Fulkerson algorithm. Geometric algorithms Convex hull of a set of points (in 2-d). Relevant QAA Computing Curriculum Sections: Data Structures and Algorithms",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "72.26",
			"Area" : "Algorithms and Data Structures",
			"Prerequisites" : [],
			"Feedback" : ["Attend all lectures and tutorials because it is WORTH IT",
						  "Do not take this course",
						  "Don't go to lectures. Read the book instead.",
						  "Prepare for boring lectures haha",
						  "The course is hard if you do not like proofs, but I found it really interesting and I learnt some new algorithms. It is really useful if you want to improve your algorithmic knowledge, but be prepared to be challenged. Bear in mind that you mind have to do some individual studying to actually understand."]
		},
		{
			"Name" : "Computational Cognitive Science",
			"Code" : "INFR10054",
			"Summary" : "This course aims to introduce students to the basic concepts and methodology needed to implement and analyse computational models of cognition. It considers the fundamental issues of using a computational approach to explore and model cognition. In particular, we explore the way that computational models relate to, are tested against, and illuminate psychological theories and data. The course will introduce both symbolic and subsymbolic modelling methodologies, and provide practical experience with implementing models. The symbolic part will focus on cognitive architectures,while the subsymbolic part will introduce probabilistic models.",
			"Course Description" : "This course aims to introduce students to the basic concepts and methodology needed to implement and analyse computational models of cognition. It considers the fundamental issues of using a computational approach to explore and model cognition. In particular, we explore the way that computational models relate to, are tested against, and illuminate psychological theories and data. The course will introduce both symbolic and subsymbolic modelling methodologies, and provide practical experience with implementing models. The symbolic part will focus on cognitive architectures,while the subsymbolic part will introduce probabilistic models.",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "58.80",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["Don't skip the lectures, can be difficult to catch up from just the slides.",
						  "It is a challenging yet very nice introduction to the area. Warning: There is a lot of probabilistic theories/concepts/thinking involved, turning theories from psychology into computational models is assumption- and maths-heavy :-)",
						  "Refresh your probability and calculus knowledge before starting this course! It's a fairly gentle course if you keep up with the lectures and tutorials and the recommended textbook is fantastic for supplementing these.",
						  "Be prepared that this course is rather challenging but do not be scared to actually open up because once you're through the worst bit it actually all starts making sense."]
		},
		{
			"Name" : "Computer Communications and Networks",
			"Code" : "INFR10074",
			"Summary" : "This is a comprehensive first course in Computer Communications and Networks, focusing on fundamental concepts, principles and techniques. The course will introduce basic networking concepts, including: protocol, network architecture, reference models, layering, service, interface, multiplexing, switching and standards. An overview of digital communication from the perspective of computer networking will also be provided. Topics covered in this course include: Internet (TCP/IP) architecture and protocols, network applications, congestion/flow/error control, routing and internetworking, data link protocols, error detection and correction, channel allocation and multiple access protocols, communication media and selected topics in wireless and data centre networks. It will cover recent advances in network control and management architectures by introducing the concepts of software-defined networking (SDN) and network (function) virtualisation. Students taking this course will gain hands-on experience in network programming using the socket API; network traffic/protocol analysis; and on assessment of alternative networked systems and architectures.",
			"Course Description" : "* Introduction to Computer Networking and the Internet * Digital Communication Basics * The Application Layer with comprehensive treatment of networked applications (incl. multimedia data and applications) * The Transport Layer * The Network Layer * The Data Link Layer * The Medium Access Control Sub-Layer * The Physical Layer * Software-defined networking (SDN) * Network virtualisation and network function virtualisation (NFV) * Network management * Introduction to data centre and wireless networks * Overview and selected aspects of network security",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "70.58",
			"Area" : "Networks",
			"Prerequisites" : [],
			"Feedback" : ["It is an interesting course but it is full of theory. A lot of material to learn",
						  "The second coursework is a lot harder than the first and worth a lot more, so keep that in mind.",
						  "Very interesting if keen to learn about networks. Not very demanding but do attend the lectures, you miss a lot of information and tips if you don't",
						  "This course teaches very helpful material"]
		},
		{
			"Name" : "Computer Security",
			"Code" : "INFR10067",
			"Summary" : "Computer Security is concerned with the protection of computer systems and their data from threats which may compromise integrity, availability, or confidentiality; the focus is on threats of a malicious nature rather than accidental. This course aims to give a broad understanding of computer security. Topics include security risks, attacks, prevention and defence methods; techniques for writing secure programs; an overview of the foundations for cryptography, security protocols and access control models. ",
			"Course Description" : "The goal of this course is to introduce students to fundamental security concepts and offer them working knowledge of threats and counter-measures. The topics covered in the course are: ¿ Introduction: fundamental concepts, access control models, threat modelling. ¿ Network security: basic networking concepts, DoS, Transport layer security, Link layer security, DNS attacks, Firewalls, Intrusion detection. ¿ Usable security: basic human factors, warning design, phishing, authentication, device authentication. ¿ Cryptography: symmetric ciphers, asymmetric ciphers, MACs and hash functions, digital signatures. ¿ Cryptographic protocols: identification, authentication and key agreement, SSL/TLS, anonymity protocols, TOR. ¿ OS security: OS concepts, memory and file system, access control, file permissions, memory safety, stack-based buffer overflows. ¿ Malware: viruses, trojan horses, worms, rootkits. ¿ Web security: WWW basics, client-side attacks, session hijacking XSS, CSRF, defences, server-side attacks, SQL injection, RFI, LFI.",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "70.87",
			"Area" : "Security",
			"Prerequisites" : [],
			"Feedback" : ["Attend all the lectures as they are very informative.",
						  "Be prepared to be intellectually challenged and do the readings before each lecture otherwise you will understand only half of it.",
						  "It is not an easy course. It is important to do the reading.",
						  "It's a fun and good course, but be prepared to study a lot of cryptography and discrete",
						  "Quite challenging but really fun, would recommend",
						  "It will be challenging but rewarding, prepare to work hard and feel proud at the end"]
		},
		{
			"Name" : "Database Systems",
			"Code" : "INFR10070",
			"Summary" : "Databases are essential to maintaining the information base in almost all modern business enterprises and to electronic commerce. They are also becoming increasingly important as a fundamental tool in much scientific research. Some knowledge of databases is now essential in any of these areas. The study of databases draws on several disciplines within computer science: logic, algorithms, programming languages and operating systems. This course is an introduction to the principles underlying the design and implementation of databases and database management systems. It will cover the theoretical and practical languages that have been developed for relational databases, their implementation and optimisation. It will also cover transaction processing and concurrency control, as well as tools and techniques for decision support and data analysis. In addition, some recent developments in databases, including semistructured data and the relationship between relational databases and XML documents, will be introduced.",
			"Course Description" : "- Overview of database management systems and the relational model - Database design: E-R diagrams, constraints, normal forms - Query languages: relational algebra and calculus - Database access from applications: embedded and dynamic SQL - Storage and indexing: B-trees, hashing - Query evaluation and optimisation: join strategies, query plans - Scheduling and concurrency control: transaction management, serializability, locking - Data warehousing and decision support: OLAP, view materialisation and maintenance - Deductive databases: Datalog and recursive queries - Incomplete data: null values and certain answers - Semistructured data: XML documents, DTDs, query languages for XML",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "68.56",
			"Area" : "Data Science",
			"Prerequisites" : [],
			"Feedback" : ["Do take it if you're interested in databases and want to learn SQL. You'll learn both so make sure you're comfortable with learning the theory behind databases.",
						  "Go for it, especially if you finally understood Computational Logic at the end of first semester first year and if you enjoyed INF2D -Agents and Reasoning",
						  "It's a really good course if you don't know much about SQL. If you already know plenty, it might not be able to teach you a lot.",
						  "Would recommend; workload is reasonable and at a good level",
						  "Continuously study, ask for help as soon as you need it and don't wait, and start early on the homework."]
		},
		{
			"Name" : "Compiling Techniques",
			"Code" : "INFR10065",
			"Summary" : "This course describes the phases of a modern programming language compiler with an emphasis on widely-used techniques. The course project will require students to implement a complete compiler from scratch for a simple programming language, targeting a real machine assembly such as MIPS. Students will also learn about implementing a compiler pass in a real compiler framework. ",
			"Course Description" : "* Introduction: structure of a compiler * Lexical analysis: tokens, regular expressions, Lex * Parsing: context-free grammars, predictive and LR parsing * Abstract syntax: semantic actions, abstract parse trees * Semantic analysis: symbol tables, bindings, type-checking * Stack frames: representation and abstraction * Intermediate code: representation trees, translation * Basic blocks and traces: canonical trees and conditional branches * Instruction selection: algorithms for selection, RISC and CISC * Liveness analysis: solution of dataflow equations * Register allocation: colouring by simplification, coalescing * Real assembly language: ARM or MIPS * Advanced Topics may include: automatic parallelisation, popular open-source compilers: GCC, LLVM ",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "78.95",
			"Area" : "Programming Language",
			"Prerequisites" : [],
			"Feedback" : ["Be prepared to work a lot and work hard. The content is by no means challenging but does require rigorous and careful thinking.",
						  "Get started with writing a compiler as soon as possible. A lot of work.",
						  "Start the work early and be very careful and thorough when you do.",
						  "Depending on how fast and good a coder you are, you might find this course moderately easy or challenging"]
		},
		{
			"Name" : "Introductory Applied Machine Learning",
			"Code" : "INFR10069",
			"Summary" : "Since the early days of AI, researchers have been interested in making computers learn, rather than simply programming them to do tasks. This is the field of machine learning. The main area that will be discussed is supervised learning, which is concerned with learning to predict an output, given inputs. A second area of study is unsupervised learning, where we wish to discover the structure in a set of patterns; there is no output 'teacher signal'.The primary aim of the course is to provide the student with a set of practical tools that can be applied to solve real-world problems in machine learning, coupled with an appropriate, principled approach to formulating a solution.",
			"Course Description" : "Introduction to Machine Learning and its Goals. Introduction to Data and Models. Memory based methods. Decision Trees. Error functions, Minimizing Error. Regression, Logistic Regression, Neural Networks. Margin Based Methods: Perceptron, Support Vector Machines. Naïve Bayes. Dimensionality Reduction. Clustering: K-means, Simple Gaussian Mixture Models, Hierarchical Clustering. Boosting Approaches. Model Averaging, Mixtures of Experts. Evaluation of Performance.",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "67.49",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["Be prepared to learn on your own and definitely check Coursera for a very similar course. Also do all the labs and coursework in a timely manner and studying for the exam will be a piece of cake",
						  "Definitely a demanding course but exciting and lets you practice all the interesting stuff you learned.",
						  "Is a good introductory course. However, expect to spend a lot of time on the assignments.",
						  "It is a fast paced course. Make sure you know some machine learning before getting into this course",
						  "It's a great practical course for ML."]
		},
		{
			"Name" : "Introduction to Theoretical Computer Science",
			"Code" : "INFR10059",
			"Summary" : "This course introduces the fundamental concepts of the theory of computer science: what does `computing' mean? Are all `computers' basically the same? Can we tell whether our programs are `correct' - and what does `correct' mean, anyway? Can we solve problems in reasonable time, and can we tell whether we can? The course concentrates primarily on conceptual understanding, but adds enough detail to allow students to go on to further courses, and illustrates how the fundamental concepts are reflected throughout the discipline.",
			"Course Description" : "The first section of the course asks the question, what does it mean to compute? We start with very simple abstract computers, and argue they can do everything real computers can do. We then ask, can we solve every computational question? The answer, which which Turing shocked the mathematicians of the 1930s, is no, with a remarkably easy but beautiful argument (introduced at the end of Inf2A). We then explore some different, but always equivalent, ways of defining a computer. We finish the section by asking how we can compare the difficulty of different problems, and introduce the idea of reduction as a way of compiling one problem into another. Technically, this covers register machines, undecidability, Turing machines, and reductions.  The second section thinks about how hard it is to solve solvable problems, leading to one of the most important problems in all mathematics, and the foundation of internet security. We start by reprising Inf2A analysis of algorithms, and then discuss the idea of classifying problems as `tractable' (easy) or `intractable' (hard). We find that the idea of algorithms whose running time grows polynomially in the problem size is a good mathematical definition of `tractable', though not always a practical one. After making this more precise, we ask what happens if we're allowed to just check all the possible answers in parallel - does this give us more problem-solving power? The question is made precise by the concept of NP, and we show that there are hardest such problems, such as the famous Travelling Salesman. Although the question is easy to ask, nobody knows how to answer it. This is P = NP - if you can solve it, you win a million dollars, and fame for as long as civilization lasts. So far, NP problems are very hard to solve in practice, so we discuss how to deal with them. We finish the section by talking about much harder problems still. Technically, this section covers P, NP, hardness and completeness, Cook's Theorem, P = NP, and the complexity hierarchy above NP.  The third section considers a different way of seeing computation. Haskell needn't be seen as a programming language, it can be the computer itself. We'll show how the lambda-calculus (on which Haskell is based) can do all the computing our other models could. Unlike the register and Turing machines, lambda-calculus lets us easily use types, which get rid of a whole class of possible bugs from our programs. This typing underlies almost all modern languages, including such recent things as generics in Java. We'll show how we can decide whether a lambda program is correct in its type, and even how we can do the typing automatically, instead of making the programmer do it. It turns out that this latter is one of those weird problems that is ridiculously hard in theory, but perfectly doable in practice, which bring us back to the complexity hierarchies of the second section. Technically, this covers lambda-calculus, simple types, polymorphism, type checking and type inference.  Register and Turing machines, undecidability, reductions. Intractability and growth rates. P and poly-time reductions, NP, hardness and completeness. Cook's Theorem. P = NP. Beyond NP. Lambda-calculus, through to simply-typed lambda, type safety, polymorphism, type inference and Hindley-Milner.",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "72.74",
			"Area" : "Theory of Computation",
			"Prerequisites" : [],
			"Feedback" : ["Do the coursework as the semester progresses - it makes it a lot more manageable, and the questions roughly correspond to material taught each week",
						  "Hard work if you're not already proficient at this type of thing but worth it.",
						  "Mathematics and proofs heavy, but extremely well explained so that even if you're struggling you're unlikely to fall behind, would recommend.",
						  "Read the notes! They are good! And do the coursework as soon as you can!"]
		},
		{
			"Name" : "Professional Issues",
			"Code" : "INFR10022",
			"Summary" : "There are many commercial, engineering and professional issues, complementary to the necessary scientific knowledge and technical skills, that impinge on the work of the computing professional. The Professional Issues course aims to provide a general awareness of these issues and to cover some of them in depth. The course will involve lectures from members of staff and visitors and directed reading.",
			"Course Description" : "* Personal Attributes: study skills, personal development, interpersonal skills; employers' views and expectations of graduates; study skills, writing skills, presentation skills. The Computing Profession: professional bodies; codes of conduct and practice. * Social and ethical issues: security, privacy, software ownership * Legal Issues: legal and regulatory frameworks; software contracts and liability; intellectual property, copyright and patents; computer misuse, data protection; health and safety. * Commercial Issues: organisational structures; finance, accounting, audit; resource management. * Computing Projects: design, prototype and product; product development cycle; marketing and market research; project management and team working; change management.  * This course consolidates complements and assesses the students appreciation and understanding of Professional Issues introduced across our curriculum.",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "68.09",
			"Area" : "???",
			"Prerequisites" : [],
			"Feedback" : ["Don't", "Not a particularly interesting course but necessary.", "The course is a lot more relevant than you think. So pay attention because the information will come handy in the future.",
						  "You will not want to go to all the lectures because some of them are quite useless (for example teaching you how to spell...) but the guest lectures are refreshing and quite interesting"]
		},
		{
			"Name" : "Software Testing",
			"Code" : "INFR10057",
			"Summary" : "This module is intended to provide in-depth coverage of software testing further to develop the introductory material covered in Informatics 2C - Software Engineering. The goal of the course is to provide students with the skill to select and apply a testing strategy and testing techniques that are appropriate to a particular software system or component. In addition the student will become a capable user of test tools; will be able to assess the effectiveness of their testing activity; and will be able provide evidence to justify their evaluation. The course will be supported by two practical exercises involving the development of appropriate tests and the application of a range of testing tools. This course is based on the IEEE Software Engineering 2004 Software Testing syllabus.",
			"Course Description" : "# Testing techniques and principles: Defects vs. failures, equivalence classes, boundary testing. # Types of defects. # Black-box vs. Structural testing. # Testing strategies: Unit testing, integration testing, profiling, test driven development. # State based testing; configuration testing; compatibility testing; web site testing. # Alpha, beta, and acceptance testing. # Coverage criteria. # Test instrumentation and tools. # Developing test plans. # Managing the testing process. # Problem reporting, tracking, and analysis. Relevant QAA Computing Curriculum Sections: Software Engineering",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "76.62",
			"Area" : "Software Engineering",
			"Prerequisites" : [],
			"Feedback" : ["It's a nice course. Take it if you like. :-)",
						  "Just take, it's useful, quite easy and the exam is open book",
						  "Many of the software testing approaches may seem intuitive and even obvious but I highly recommend taking the course simply to gain the useful confidence that will pay off in any software engineering interview or job.",
						  "This course is worth taking if you are interested in software testing methods and concepts.",
						  "I liked the professor's explanations, and found everything fairly straightforward."]
		},
		{
			"Name" : "Accelerated Natural Language Processing",
			"Code" : "INFR11125",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "6",
			"Average" : "64.96",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["Although the class might seem very difficult at first, if you put the effort in, it will get easier with time. Depending on your background, it might feel impossible for the first few weeks, but just keep with it!",
						  "I really enjoyed this course, I learned a lot. Although, I would highly recommend reading about linguistics before starting the course to make your life easier. It was very challenging, especially at the beginning.",
						  "Start early, try to keep up with the course content. You don't have to get deep understanding for each topic. Assignment 1 seems easy but people usually get less marks because of how they have written the reports.",
						  "Tough, fair, engaging."],
			"Summary" : "The course will synthesize ideas from linguistics and computer science to provide students with a fast-paced introduction to the field of natural language processing. The course will cover the most widely-used theoretical and computational models of language, including both statistical and nonstatistical approaches. The course will familiarize students with a wide range of linguistic phenomena with the aim of appreciating the complexity, but also the systematic behaviour of natural languages like English, the pervasiveness of ambiguity, and how this presents challenges in natural language processing. In addition, the course introduce the most important algorithms and data structures that are commonly used to solve many NLP problems. The course will cover formal models for representing and analyzing the syntax and semantics of words, sentences, and discourse. Students will learn how to analyse sentences algorithmically, using hand-crafted and automatically induced treebank grammars, and how to build interpretable semantic representations. The course will also cover a number of standard models and algorithms that are used throughout language processing. Examples include n-gram and Hidden Markov Models, the EM algorithm, and dynamic programming algorithms such as chart parsing.",
			"Course Description" : "Part I: Words * Inflectional and derivational morphology * Finite state methods and Regular expressions * Word Classes and Parts of speech * Sequence Models (n-gram and Hidden Markov models, smoothing) * The Viterbi algorithm, Forward Backward, EM Part II: Syntax * Syntactic Concepts (e.g., constituency, subcategorisation, bounded and unbounded dependencies, feature representations) * Analysis in CFG - Greedy algorithms---Shift-reduce parsing * Divide-and-conquer algorithms---CKY * Chart parsing * Lexicalised grammar formalisms (e.g., TAG, CCG, dependency grammar) * Statistical parsing (PCFGs, dependency parsing) Part III: Semantics, Discourse, Dialogue and Applications * logical semantics and compositionality * Semantic derivations in grammar * Lexical Semantics (e.g., word senses, semantic roles) * Discourse and dialogue (e.g., anaphora, speech acts) * Text classification and sentiment analysis * Other applications (e.g., machine translation, question answering) Methodological topics, interspersed throughout: * Issues in annotation and evaluation * Machine learning approaches (e.g., Maximum Entropy models, neural networks)"
		},
		{
			"Name" : "Advanced Databases",
			"Code" : "INFR11011",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "72.23",
			"Area" : "Data Science",
			"Prerequisites" : [],
			"Feedback" : ["Quality course, interesting material, well taught, would recommend.",
						  "Clear explanation of how database works",
						  "The lecturer really seemed to care about the quality of his teaching, and it fully paid off"],
			"Summary" : "This course aims at furthering database systems concepts through adding complexity and a more hands-on approach. In particular, we will focus on supporting multi-dimensional data in a DBMS, query optimisation, query evaluation, transaction processing and concurrency control in both a centralised and a distributed context. In terms of centralised databases, we shall start from single and multi-dimensional indexing methods, move on to join evaluation algorithms, and talk about query opimisation paradigms. We shall then focus on the issues of transaction processing, concurrency control and crash recovery. Finally, we shall revisit the previous issues in a distributed database environment.",
			"Course Description" : "* B-trees, hash-based indexes, R-trees. * Indexing structures for solid state and main memory. * Query evaluation: sorting and join processing, aggregation * Algorithmic adjustments for flash memory and main-memory systems. * Query optimisation: cost-based query optimisation, dynamic programming, randomised exploration, rule-based optimisation. * Concurrency and recovery: transactions, lock tables, main-memory concurrency control, recovery using the ARIES algorithm. * Parallel databases: parallel query evaluation, parallel and distributed transaction processing."
		},
		{
			"Name" : "Algorithmic Game Theory and its Applications",
			"Code" : "INFR11020",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "65.70",
			"Area" : "Algorithms and Data Structures",
			"Prerequisites" : [],
			"Feedback" : ["Be prepared for complex notation. However, if you put in the effort, the underlying concepts are not as hard as the notation would suggest.",
						  "Interesting and challenging course if you're not afraid of abstract definitions and heavy formalism.",
						  "This course is not for everybody; do a check and be sure you want to take this"],
			"Summary" : "Game theory is the formal study of interaction between self-interested (or goal-oriented) systems (or agents or decision makers or players), & strategic scenarios that arise in such settings. It began life in Economics in the 1940's with the work of von Neumann & Morgenstern, but has since been applied to an extraordinary range of subjects, including political science, evolutionary biology & even to inspection regimes for arms control. Game theory has for years also played an important, if less recognized, role in several branches of computer science. Applications within computer science include the use of games in automated verification & model checking to model computing systems in an unknown and possibly adverse environment. In AI games are applied to the analysis of multi-agent systems. Recently, with the advent of the internet and e-commerce, many game theoretic questions in the interplay between economics & computing have received extensive attention. These include electronic auctions, & more generally mechanism design questions (inverse game theory) related to finding incentive structures for cooperation between independent entities on the internet. Wherever game theory plays a quantitative role, algorithmic and computational questions related to solving games are also of central importance. This course aims to bring together as a coherent body of knowledge the game theoretic algorithms & models that underpin several flourishing subjects at the intersection of computer science, economics and e-commerce, & AI.",
			"Course Description" : "* Examples of diverse games. * Zero-sum two-person games: LP, simplex, LP-duality, mixed strategies and the minimax theorem. * General games in strategic form: * Equilibria and Nash's theorem. * 2-player equilibria: Lemke-Howson algorithm and its variants. * Games in Extensive form (mainly zero-sum, perfect information): * Game trees. Relation to Strategic games. * And/Or game graphs and reachability games. * bisimulation, simulation, parity games, and other omega-games on automata(finitely presented, infinite duration games). * mean value games, MDPs, and stochastic games. * Mechanism design and inverse game theory: designing games where selfish players will behave as desired. * Vickery auctions and other mechanisms. * Combinatorial auctions. * Incentive structures for the internet. "
		},
		{
			"Name" : "Automatic Speech Recognition",
			"Code" : "INFR11033",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "62.77",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["If you haven't taken Speech Processing, review materials from that course if possible. It's highly relevant.",
						  "Great lectures, the lectures were interesting, readings were relevant and helped better understand the material covered.",
						  " Working through the coursework was frustrating (because Kaldi is frustrating), but it really helped solidify the material that was covered in class"],
			"Summary" : "This course covers the theory and practice of automatic speech recognition (ASR), with a focus on the statistical approaches that comprise the state of the art. The course introduces the overall framework for speech recognition, including speech signal analysis, acoustic modelling using hidden Markov models, language modelling and recognition search. Advanced topics covered will include speaker adaptation, robust speech recognition and speaker identification. The practical side of the course will involve the development of a speech recognition system using a speech recognition software toolkit.",
			"Course Description" : "* Signal analysis for ASR * Statistical pattern recognition (Bayes decision theory, Learning algorithms, Evaluation methods, Gaussian mixture model, and EM algorithm) * Hidden Markov Models (HMM) * Context-dependent models * Discriminative training * Language models for LVCSR (large vocabulary continuous speech recognition) * Decoding * Robust ASR (Robust features Noise reduction, Microphone arrays) * Adaptation (Noise adaptation, Speaker adaptation/normalization, Language model adaptation) * Speaker recognition * History of speech recognition * Advanced topics (Using prosody for ASR, Audio-visual ASR, Indexing, Bayesian network) * speech recognition applications (including privacy implications)"
		},
		{
			"Name" : "Blockchains and Distributed Ledgers",
			"Code" : "INFR11144",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "72.49",
			"Area" : "Security",
			"Prerequisites" : [],
			"Feedback" : [" Begin the coursework early to have time for exploration if you're not familiar with programming smart contracts or interacting with blockchains in general.",
						  " If you are interested in blockchain technology/ distributed applications the course won't let you down. It is good course explaining the high-level concepts of blockchain technology from multiple standpoints. The course is not particularly demanding in demanding terms of a mathematical background but requires a lot of critical thinking. The course complements really well with the course Introduction to Modern Cryptography. If a student takes both courses he will have a good foundation on Blockchain and he will be able to perform individual research on the subject.",
						  "The course covers blockchain technology from all perspectives and gives you multiple ways to approach the subject"],
			"Summary" : "Blockchain technology and distributed ledgers have been hailed as a turning point in scaling information technology services at a global level. Although the digital currency Bitcoin is the best-known Blockchain application today, the technology is set to play a much broader role in cyber security innovation. This course is an introduction to the design and analysis of blockchain systems and distributed ledgers and is meant to be taught in parallel to the Introduction to Modern Cryptography course of the same level (INFR11131) every other year (with the latter course as a prerequisite or co-requisite).",
			"Course Description" : "Syllabus: 1. Introduction to blockchain. What is a distributed ledger. Transactions. Digital Signatures. 2. The consensus layer. Basic Properties. Proof of Work. 3. Robust Transaction Ledgers. Properties and Objectives. Permissioned, permissionless ledgers. 4. Privacy Issues. Anonymity, Pseudonymity, Unlinkability. Zero-Knowledge Proofs. 5. Scalability Issues. Byzantine agreement protocols. 6. Blockchain as a platform. Smart Contracts. 7. Secure multiparty computation techniques and their application to blockchain protocols. 8. Alternative techniques to proof of work for blockchain protocols, proof of stake/space. 9. Game theoretic analysis of blockchain protocols. 10. Name and object registries. Reputation systems. Policy issues related to blockchain."
		},
		{
			"Name": "Compiler Optimisation",
			"Code" : "INFR11032",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "67.42",
			"Area" : "Programming Language",
			"Prerequisites" : [],
			"Feedback" : ["Don't take other time-consuming courses, there will not be enough time",
						  "Only take it if you are really interested in compilers.",
						  "Broad range of very challenging topics. Hugh is very keen to answer questions."],
			"Summary" : "This course introduces students to modern techniques in efficient implementation of programming languages. Modern processors and systems are designed based on the assumption that a compiler will be able to effectively exploit architectural resources. This course will examine in detail techniques to exploit instruction level parallelism, memory hierarchy and higher level parallelism. It will examine classic static analysis approaches to these problems and introduce newer feedback directed and dynamic approaches to optimisation. The course work will require students to implement selected optimisations in a research compiler and critically review literature in compiler optimisation.",
			"Course Description" : "*Compiler Construction, phase order, compilation as optimisation *Architecture costs: Parallelism and Latency in uni and multi-processors *Architecture independent optimisation, dataflow analysis, lattices and fixed points *Code generation, register allocation and scheduling in superscalar and vliw processors *High level analysis based on dependence analysis. Intra and inter procedural analysis, whole program analysis. *High level transformations including linear algebraic formalisation, unimodular transformations and space/time representation *Automated parallelisation. shared and distributed memory models. Linear algebraic approach to parallelisation. *Adaptive optimisation: Feedback directed optimisation, iterative compilation, program specialisation and dynamic compilation eg JIT, DBT *Compiler infrastructure case studies: SUIF, Machine SUIF, JIKES *Current themes:low power compilation, automatic compiler generation and machine learning."
		},
		{
			"Name": "Computer Animation & Visualisation",
			"Code" : "INFR11067",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "69.23",
			"Area" : "Graphics",
			"Prerequisites" : [],
			"Feedback" : ["Taking Computer Graphics as well helps with the understanding of basic concepts",
						  "The lecturer was amazing as he explained the content in an understandable way.",
						  "Coursework is too hard. Why we have to use software we never used before?"],
			"Summary" : "Two major topics of Visualisation and Computer Animation are covered in this course. Visualization is a cognitive process using the powerful information processing and analytical functions of the human vision system. It has always been a major factor in scientific progress and now, with the assistance of computer graphics, it extends our vision system from sub-atomic to interstellar dimensions and allows geometric representations and simulations of any multidimensional dataset. The fundamental objective is to acquire new knowledge rather than generating pictures. This part is very practical and techniques will be illustrated with applications in the scientific, engineering and medical domains. The increasingly important field of information visualisation and visual data-mining will also be covered.",
		 	"Course Description" : "* Visualisation: definition and motivation. * Data representation: geometric abstractions; volume and surface representations, interpolation. * Fundamental algorithms: colour mapping; contouring; glyphs; volume rendering. * Advanced algorithms: flow visualisation, vector visualisation, tensor visualisation. * Advanced topics of Computer Graphics: Visualisation of environments, data processing. * Character Animation techniques: keyframe animation, inverse kinematics, facial animation, PD-control, flocking, crowd simulation. * Motion capture technologies: optical, magnetic, mechanical, gyrosensors. * Optimization-based techniques: space-time constraints, Laplacian distance shape deformation. * Physically based animation techniques: fluid animation, hair animation, cloth simulation, deformable objects."
		},
		{
			"Name": "Extreme Computing",
			"Code" : "INFR11088",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "63.93",
			"Area" : "Software Engineering",
			"Prerequisites" : [],
			"Feedback" : ["Be prepared to learn the material by yourself",
						  "I would think twice before choosing this course. In my opinion, EXC is a poorly organised course but I am hopeful that things can be improved. The slides were a high-level view of the course. Unfortunately, at lectures not much more relevant content was presented by the lecturers.",
						  "Worthwhile, useful and a bit challenging",
						  "Start the coursework early and ask questions!"],
			"Summary" : "Extreme Computing deals with the principles, systems and algorithms behind Web-scale problem solving. This touches upon the technologies and techniques used by companies such as Google, Facebook, Amazon, and Microsoft, using warehouse-scale computing and massive datasets. The course will be in three parts: the principles behind extreme computing (cloud computing, scaling, performance, privacy etc.), supporting infrastructure (distributed file systems, replication, Web services etc.) and algorithms (Map/Reduce, case studies from Natural Language Processing, rudimentary data processing, machine learning, data streaming).",
			"Course Description" : "The course is to be conceptually split into three main areas, with each area not necessarily accounting for an equal portion of the syllabus. The three areas and the material covered in each area are as follows: * Background: Motivation for new computing paradigms; introduction and differences between cloud and cluster computing; scaling, performance, privacy, economics, security, software as service. * Infrastructure: Distributed file systems; multi-tier systems, virtualisation; replication; fault tolerance; concurrent programming; web services. * Data structures and algorithms: decentralised data structures (e.g., peer-to-peer systems); programming frameworks (e.g., Hadoop Map/Reduce); workflow languages (e.g., FlumeJava); design and implementation of Map/Reduce programs; dealing with massive amounts of data; case studies from natural language processing, data processing, machine and deep learning; and computation over infinite streams. The course will also deal with the legal, social, ethical, and professional issues involved in remotely storing data in cloud deployments and will also deal with potential solutions to these problem"
		},
		{
			"Name": "Human-Computer Interaction",
			"Code" : "INFR11017",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "78.86",
			"Area" : "???",
			"Prerequisites" : [],
			"Feedback" : ["A very well-organised course for student who want to go into human-computer interaction or UX design.",
						  "It is different from the usual Computer Science courses but it is useful for work.",
						  "Strongly recommend this course if student is interested in design.",
						  "Plan enough time for the coursework as it seems easy in the beginning, but requires much time to complete."],
			"Summary" : "The design and implementation of efficient, effective and user friendly computer systems, including software objects and physical internet-enabled things, depends upon understanding both the technology and its users. Only then can designers be confident that these information appliances will be properly matched to the skills, knowledge and needs of their users. The study of Human-Computer Interaction (HCI) seeks to combine perspectives and methods of enquiry drawn from disciplines such as Interaction Design, Psychology and Sociology with the tools, techniques and technologies of Computer Science to create an approach to design which is both relevant and practical.",
			"Course Description" : "* Background--the development and scope of HCI. Practical goals. * HCI relevant issues in human perception, memory and thinking processes. * Approaches to designing information appliances--software objects and physical things. * Design methodologies and notations--levels of interface design. Task analysis, grammars, state charts. * Techniques and technologies--dialogue styles, information presentation, protocols for human-to-machine and machine-to-machine interactions; mobile computing, distributed wireless computation, wireless sensors. * The design process--user involvement, iterative design, prototyping. * Evaluation--methodologies, formative and summative. Performance analysis. * Specific issues in HCI: the internet of things; novel interfaces. * A theme running through the course is the relevance of the social context on Interaction Design."
		},
		{
			"Name": "Introduction to Modern Cryptography",
			"Code" : "INFR11131",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "63.93",
			"Area" : "Security",
			"Prerequisites" : [],
			"Feedback" : ["The lecture notes are very well structured. I found them useful and well-explained.",
						  "Only take this course if you have strong foundations in proofs and probability theory, and make sure to take good notes during class and ask questions whenever explanations are not clear",
						  "Very mathematical. This course is about why (mathematically) something is cryptographically secure.",
						  "Interesting topic."],
			"Summary" : "Cryptography is the formal study of the notion of security in information systems. The course will offer a thorough introduction to modern cryptography focusing on models and proofs of security for various basic cryptographic primitives and protocols including key exchange protocols, commitment schemes, digital signature algorithms, oblivious transfer protocols and public-key encryption schemes. Applications to various problems in secure computer and information systems will be briefly discussed including secure multiparty computation, digital content distribution, e-voting systems, digital payment systems, cryptocurrencies.",
			"Course Description" : "The area of cryptography focuses on various problems pertaining to secure communication and computation. It entails the study of models that express security properties as well as the algorithms and protocols that are the implementation candidates for satisfying these properties. An important dimension of modern cryptography is the design of security proofs that establish security properties. Such proofs are conditional on assumptions that fall in two categories: 'system assumptions' such as the faithful execution of code, or the availability of private randomness and 'computational assumptions' that are related to the computational complexity of various problems (including factoring large numbers and others). Students will learn to model security problems, design protocols and prove them secure under precisely formulated system and computational assumptions."
		},
		{
			"Name": "Introduction to Quantum Computing",
			"Code" : "INFR11099",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "67.00",
			"Area" : "Theory of Computation",
			"Prerequisites" : ["Introduction to Linear Algebra", "Probability with Applications"],
			"Feedback" : ["This is a great introduction to quantum computing that would probably be difficult to get introduced to otherwise",
						  "Keep up with the subjects from the beginning. Otherwise it is nearly impossible to follow the next lectures, and learning the stuff completely at home is hard",
						  "Both the lectures and tutorials were fantastic."],
			"Summary" : "The aim of this course is to give students a basic overview of the rapidly growing field of Quantum Computation (QC). The course will start with a brief introduction of the mathematical framework of QC. The two models of quantum circuit and measurement-based quantum computing, will be introduced. Through these models various key concepts in QC such as entanglement and teleportation will be discussed. In order to compare QC and classical computing, simple quantum algorithms with their complexity analysis will be presented. We finish the course by highlighting the recent development of the field in secure delegated QC.",
			"Course Description" : "- Basic concepts from Linear Algebra necessary for understanding the axioms of Quantum Mechanics - Axioms of Quantum Mechanics, describing quantum system, quantum operators, composition, entanglement and measurements - The no cloning, no deleting theorems and the consequences for computation - Quantum Computing via quantum circuit model: Description of qubit and universal set of gates. - Quantum space and depth complexity and oracle model - Classical simulation of quantum circuit and Gottesman-Knill Theorem - Quantum Algorithms: Groverżs Search and Deutsch-Jozsa problem - The first quantum protocols: Quantum teleportation and super dense coding - Quantum Computing via measurement-based model: Description of graph state and measurement calculus - Advanced Topics: Information flow in measurement-based model, unconditionally secure quantum cloud computing"
		},
		{
			"Name": "Machine Learning Practical",
			"Code" : "INFR11132",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "4",
			"Average" : "74.14",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["Pick something nice for the group project and you'll have a good time. Also install conda with Intel's MKL libraries for nonpotato speed when training neural nets.",
						  "Start work on the assignments as early as possible. It will take a while to get your code working, and then you still need plenty of time to run the experiments.",
						  "This is more like a 30 unit course (15 units per semester) - it is a lot of work but worth it in the end I think",
						  "I really learned a lot. This course requires far more work than any other course and the weeks before the deadlines are very stressful, but it is incredibly instructive, both in terms of deep learning and research skills (organisation, writing...). Instructors were very responsive and made themselves available."],
			"Summary" : "This course is focused on the implementation and evaluation of machine learning systems, and is lab-based. Students who do this course will obtain experience in the design, implementation, training, and evaluation of machine learning systems. Semester one comprises lectures, labs, and individual coursework. Semester two is based around small group projects, and also includes tutorials and guest lectures. This 20 credit course replaces INFR11119 Machine Learning Practical (10 credits). Note: this course is not a stand-alone introduction to machine learning. Please see Other Requirements for details.",
			"Course Description" : "The course covers practical aspects of machine learning, and will focus on practical and experimental issues in deep learning and neural networks. Topics that are covered include: * Optimisation and learning rules * Regularisation and normalisation * Neural networks for classification * Convolutional Neural Networks * Recurrent Neural Networks MLP is coursework-based, with lectures to support the additional material required to carry out the practical. Students who complete this course will have experience in the design, implementation, training, and evaluation of machine learning systems. MLP is a two-semester course. During semester 1 the course will focus on developing a deep learning framework based on experiments using the task of classification of handwritten digits using the well-known MNIST dataset. The course uses a Python software framework, and a series of Jupyter notebooks. There is a series of ten weekly lectures in semester 1 to provide the required theoretical support to the practical work. Semester 2 will be based on small group projects, with a focus on using deep neural networks within the context of a miniproject, using an open source toolkit such as TensorFlow or PyTorch. Lectures in semester 2 will support the coursework, and also provide insights to the current state of the art in this very fast moving area."
		},
		{
			"Name": "Machine Learning and Pattern Recognition",
			"Code" : "INFR11130",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "4",
			"Average" : "59.44",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["Have some background knowledge before move in and prepare your math to a suitable level.",
						  "It has high demand of mathematics, but really worth taking for those who want to do research or work in machine learning area.",
						  "It is a very interesting course with quite a lot of material covered.",
						  "MLPR is a hard course and requires high level of math and coding",
						  "Spend more time on it"],
			"Summary" : "Machine learning is a field devoted to developing algorithms that adapt their behaviour to data, providing useful representations of the data and/or predictions. This course covers some fundamental theoretical concepts in machine learning, and common patterns for implementing methods in practice. The intended audience are those wanting the background required to begin research and development of machine learning methods. This is an advanced course. Students should not choose this class without the required background (see Other Requirements box); students without this background are strongly advised to take a more practical-based course, such as Introduction to Applied Machine Learning (INFR10063). This 20 credit course replaces Machine Learning & Pattern Recognition (Level 11) (INFR11073) - 10 credit course.",
			"Course Description" : "The precise set of methods and algorithms used to illustrate and explore the main concepts will change slightly from year to year. However, the main topic headings are expected to be fairly stable. - Classification and Regression: Linear Regression, logistic regression, Bayes classifiers - Expanded feature representations: Basis functions, neural networks, kernel methods - Generalization, regularization and inference: Penalized cost functions, Bayesian prediction, learning theory - Model selection, pruning and combination: Cross-validation, Bayesian methods, sparsifying regularizers, ensemble methods. - Representation and metric learning: dimensionality reduction, clustering, feature learning  To support these topics we will also cover: - Optimization and Inference algorithms: Stochastic gradient descent, simple Monte Carlo ideas, and more specialized methods as required. Practical issues: - Formulating problems as machine learning, adapting methods to fit problems. - Numerical and programming issues important for machine learning. - Ethical issues, such as responsible application of methods and privacy concerns."
		},
		{
			"Name": "Performance Modelling",
			"Code" : "INFR11082",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "69.25",
			"Area" : "Graphics",
			"Prerequisites" : [],
			"Feedback" : ["Introduction to modelling systems and evaluate their performance. Good course for this high-level reasoning and formalism.",
						  "Just do it! Coursework and classwork are engaging, flipped classroom model works really well and you feel really engaged with the lecturer!",
						  "A lot of hands on problem solving with real modelling tools.",
						  "Video lectures and organization was very good"],
			"Summary" : "This course teaches various aspects of computer-aided modelling for performance evaluation of (stochastic) dynamic systems. The main focus is on stochastic modelling of computer systems and communication networks to assess performance characteristics such as throughput, response time etc.; however other dynamic systems such as manufacturing systems may also be considered. The central concept of the course will be that a model is as an abstract representation of a system which can be used as a tool to derive information about dynamic behaviour of the system. The more detail we invest in the model, the more sophisticated the information we can extract from it. As the course progresses the model will become increasingly detailed; the corresponding solution techniques will similarly become more complex, relying on increasing levels of computer assistance.",
			"Course Description" : "*Modelling and performance evaluation: models as tools; equilibrium and transient behaviour; analytic vs. algorithmic models. Revision of basic probability concepts. *Making use of models: deriving performance measures from an equilibrium distribution; choosing the parameters for a model; measurement and workload modelling; experimentation. *Representing systems directly as analytic models: operational laws such as Little's Law, simple queues and Markov processes; solving equations to find equilibrium behaviour. *Representing systems as algorithmic models: process-oriented and event-oriented simulation, variance reduction and stopping conditions. *High-level modelling languages: the stochastic process algebra PEPA, stochastic Petri nets and networks of queues."
		},
		{
			"Name": "Parallel Programming Languages and Systems",
			"Code" : "INFR11023",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "67.84",
			"Area" : "Programming Language",
			"Prerequisites" : [],
			"Feedback" : ["Good course.", "Lectures give a good introduction, but expect to practise on your own if you want to truly master concurrent programming.", "Clear explanation of fundamental concepts, neat (and printed!) overheads and organisation of the course",
						  "Well-established lecture materials and a good lecturer."],
			"Summary" : "The module familiarises students with the issues involved in designing, implementing and applying parallel programming systems. Initial motivation will be provided by consideration of a number of typical high performance applications and parallel architectures. This will highlight the role of parallel software systems as a means of bridging the gap between these and allow abstraction of the issues which must be addressed by any such system (partitioning, communication, agglomeration, scheduling). It will explore the ways in which these challenges have been addressed by a range of systems, including both de facto standards and more adventurous research projects.",
			"Course Description" : "* Introduction. Conceptual and architectural models of parallelism. Parallel algorithmic paradigms and simple parallel algorithms.Iterative, recursive pipeline and bag-of-task parallelism. * Realisation in Pthreads and Java. * Issues in message passing programming. Channels and synchronization models. * Realisation in MPI: communicators, simple and collective operations * Selected case studies highlighting alternative approaches, for example, * Associative models. Linda, tuple space and related primitives. * Threading Building Blocks."
		},
		{
			"Name": "Principles and Design of IoT Systems",
			"Code" : "INFR11150",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "4",
			"Average" : "65.5",
			"Area" : "Internet of Things",
			"Prerequisites" : [],
			"Feedback" : ["Its a lot of work because you need to go from the sensor board (c++) to the android app (java) and merge everything, plus write a report and a presentation. However, take it, not many people out there knows how to use sensors for doing real time analytics.",
						  "The practical implementation of this course provides the students with on hands experience with IoT systems. This is a very interesting course and exciting one. There is no much pressure on the students, they are given time to think about approaches to take to complete the practicals and feedback with the course tutor helps to guide the path to follow. The course is not rushed and the concept is discussed properly",
						  "The technology narrowed us in what we could actually do. I felt that the nordic board was too complex for doing easy stuff."],
			"Summary" : "The course 'Principles and Design of the Internet of Things Systems' (PDIoT) is concerned with the emerging discipline of digitising the physical world with wireless sensors, analysing the sensor data to provide actionable information, and influencing the physical world via actuators, with an optional human in the loop. The course imparts foundational concepts in IoT in a series of 10 lectures and students gain hands-on experience by realising their application idea as a demonstratable IoT system prototype. The lectures will be illustrated with a number of IoT case studies undertaken by the lecturer over the past fifteen years.",
			"Course Description" : "The course aims to deliver a sound understanding of the design and analysis of Internet of Things through lectures and practice. The lectures provide the foundational knowledge in sensors and actuators, fusion of data from multiple sensors, sensor data calibration and topics in sensor data analytics: pre-processing and extraction of features in time-series sensor data, and classification methods using a selection of machine learning techniques. The students conduct a major piece of coursework working in pairs to develop an application using an IoT platform together with a mobile application. Students will experience all the stages in the design and implementation of a complex system - from its specification to the demonstration of a working prototype. They will be exposed to aspects of embedded systems programming, sensor data analytics using machine learning, data collection, algorithm development, user interface design, mobile application design, system integration and testing. The goal is to develop a step counter which should detect walking on level ground and climbing stairs. Each student pair will be given an NRF52DK dev board with Bluetooth wireless connection, and triaxial accelerometer and gyroscope sensors. On-device firmware will be developed using the mbed platform and Android will be used for an accompanying mobile application. Each pair will demonstrate a working prototype at the end of 10 weeks and deliver a written report by the end of Week 1 in the second semester."
		},
		{
			"Name": "Randomness and Computation",
			"Code" : "INFR11089",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "67.50",
			"Area" : "Theory of Computation",
			"Prerequisites" : [],
			"Feedback" : ["Don't.", "The course is remarkably badly taught.", "Study on your own the material from the book. Don't go to the lectures or the tutorials. They're a waste of time."],
			"Summary" : "This course is about probabilistic methods and their application to computer science. The course introduces basic models and techniques and applies these techniques to the design of various randomized algorithms, data structures, and distributed protocols. Special emphasis will be given on applications of these ideas to other areas of computer science (e.g. networking, machine learning, etc).",
			"Course Description" : "- Introduction: Las Vegas and Monte Carlo algorithms (Elementary Examples: checking identities, fingerprinting) - Moments, Deviations and Tail Inequalities (Balls and Bins, Coupon Collecting, stable marriage, routing) - Randomization in Sequential Computation (Data Structures, Graph Algorithms) * Randomization in Parallel and Distributed Computation (algebraic techniques, matching, sorting, independent sets) * Randomization in Online Computation  (online model, adversary models, paging, k-server) - The Probabilistic Method (threshold phenomena in random graphs, Lovasz Local Lemma) - Random Walks and Markov Chains (hitting and cover times, Markov chain Monte Carlo)"
		},
		{
			"Name": "Software Architecture, Process, and Management",
			"Code" : "INFR11038",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "66.45",
			"Area" : "Software Engineering",
			"Prerequisites" : [],
			"Feedback" : ["Good overview and lecturer but content wise is a bit too light.", "Groupwork with 8-10 people per group (which were assigned by lecturer) is challenging",
						  "This course if definitely interesting for understanding the structure of software architecture and the group assignment does develop some useful skills."],
			"Summary" : "Large-scale systems differ from small-scale system in the challenges they pose in capturing, and managing the process of delivering systems that conform to, quality attribute requirements (e.g. availability, performance, security). Software Architecture provides a framework for managing these aspects of systems. This course introduces Software Architecture concepts and provides experience of the use of Software Architecture in the development process and management of systems.",
			"Course Description" : "Software Architecture: Quality Attributes; Large-scale systems; Quality Attribute Scenarios; Architectural Tactics; Design Checklists; Tradeoffs; Architectural Patterns; Product Lines; Exemplar Quality Attributes (Availability; Performance; Security; Testability; Usability; ¿); Case Studies (Apache, Linux, Real-time Architecture, Medical Systems, Banking Systems). Software Architecture in the Development Process: Architecture in Processes (Traditional Vmodel, Risk-centric, Agile), Process Improvement, Modern Developments (e.g. DevOps). Management Aspects: Tools through the process; planning; tracking; cost management; people and teams."
		},
		{
			"Name": "Secure Programming",
			"Code" : "INFR11098",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "61.51",
			"Area" : "Security",
			"Prerequisites" : [],
			"Feedback" : ["An interesting practical course", "Good if they enjoyed the Computer Security course.",
						  "The labs had interesting content."],
			"Summary" : "This course studies the principles and practices of secure programming. Secure programming means writing programs in a safe fashion, to avoid vulnerabilities that can be exploited by attackers. It also means using security features provided by libraries, such as authentication and encryption, appropriately and effectively. A range of programming platforms will be considered, ranging from low-level (e.g. Android OS), through web programming (e.g., JavaScript and Python) to high-level large-scale languages (e.g., Java). New and emerging language-based security mechanisms will be examined, including ways of specifying and enforcing security policies statically and dynamically (e.g., to enforce access controls or information flow policies).",
			"Course Description" : "- Security maintainance of deployed software systems, including 'penetrate-and-patch', vulnerability enumeration (CVE IDs) and classification (CWE taxonomy). - Secure programming techniques and common pitfalls, covering input validation, output filtering, use of cryptography and authentication. Standards such as the OWASP guidelines and the CERT Secure Coding Standards. - Malware (including adware, spyware) and its use of software vulnerabilities as an attack vector. Programming resilience against malware. - Low-level programming platforms, VMs and their security provisions, for example including process isolation, capabilities and permissions. Mobile operating system platforms as examples. - Web programming platforms and security provisions. HTTP protocol, forms, clientside and server-side threats and their avoidance. - High-level and Enterprise security programming, including cryptography via cryptographic libraries, authentication via GSSAPI. - Security APIs and their distinction from cryptography APIs. Use and design of security APIs for key management, hashing and encryption. Implementation in hardware and software. - Language-based techniques for assisting security programming, using dynamic enforcement via runtime monitoring and static enforcement via program analysis. Example tools. - Methods and tools for taint checking and information flow tracking to manage programming with sensitive data. Privacy risks with lack of encapsulation. - Methods and tools for controlling resource usage with permissions and capabilities, and static analysis for guarantees in advance."
		},
		{
			"Name": "Social and Technological Networks",
			"Code" : "INFR11124",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "72.40",
			"Area" : "Networks",
			"Prerequisites" : [],
			"Feedback" : ["Plan enough time for the coursework and meet the lecturer in his office to talk about your project. The descriptions are too vague and too open.",
						  "I found that the content was very relevant and inspiring. Provides a good perspective how people/things connect. This is very useful.",
						  "It's actually a very interesting topic, with a lot of real world applications. Real fun to learn about epidemics and influence in a network."],
			"Summary" : "In this course, we will study core properties of networks arising in various social, scientific and technological contexts. We will see techniques for their analysis, and applications in social networks, World Wide Web, Internet, IoT etc. The course will cover fundamental theories and techniques from machine learning, algorithms and mathematics. We will see the relevance of these techniques in real networks, as well as use of network-based techniques in more general data analysis. The course will involve theoretical analysis in class, development of algorithms, and writing of programs to analyse network data.",
			"Course Description" : "The course will study computational, mathematical and data analysis aspects of networks. Typical topics will include properties of social networks, epidemics, spread of innovation, random graphs, metric properties, preferential attachments and power law networks. It will cover relation to data analysis and machine learning: including clustering and community detection, submodularity, optimization, embedding (dimension reduction) and classification. Other current topics will be covered as appropriate."
		},
		{
			"Name": "Text Technologies for Data Science",
			"Code" : "INFR11145",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "71.57",
			"Area" : "Data Science",
			"Prerequisites" : ["Practical hands-on experience. The course content and coursework were very well connected and improved understanding.",
							   "I found the practical assignments interesting and informative. "],
			"Feedback" : [],
			"Summary" : "This course teaches the basic technologies required for text processing, focussing mainly on information retrieval and text classification. It gives a detailed overview of information retrieval and describes how search engines work. It also covers basic knowledge of the main steps for text classification. This course is a highly practical course, where at least 50% of what is taught in the course will be implemented from scratch in course works and labs, and students are required to complete a final project in small groups. All lectures, labs, and two course works will take place in Semester 1. The final group project will be due early Semester 2 by week 3 or 4.",
			"Course Description" : "Syllabus: * Introduction to IR and text processing, system components * Zipf, Heaps, and other text laws  * Pre-processing: tokenization, normalisation, stemming, stopping. * Indexing: inverted index, boolean and proximity search * Evaluation methods and measures (e.g., precision, recall, MAP, significance testing). * Query expansion * IR toolkits and applications * Ranked retrieval and learning to rank * Text classification: feature extraction, baselines, evaluation * Web search"
		},
		{
			"Name": "Types and Semantics for Programming Languages",
			"Code" : "INFR11114",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "93.38",
			"Area" : "Programming Language",
			"Prerequisites" : [],
			"Feedback" : ["The lecturer explained very well in the lectures and motivated the knowledge technically and practically. The course is organised well by having a lecture followed by a tutorial to practice. The lecturer and tutors help to guide in the tutorials to understand the content of the lectures more.",
						  "The course teaches how to do formal proofs and formally reason about programming languages.",
						  "Small class. Better learning experience."],
			"Summary" : "Type systems and semantics are mathematical tools for precisely describing aspects of programming language. A type system imposes constraints on legal programs in order to guarantee their safe execution, whilst a semantics specifies what a program will do when executed. This course gives an introduction to the main ideas and methods of type systems and semantics. This enables a deeper understanding of existing programming languages, as well as the ability to design and specify new language features.",
			"Course Description" : "*Inductive definitions and proof by induction *Untyped and simply-typed lambda calculus. Variable binding. *Small step and big step semantics. *Progress and preservation theorems. *Products, sums, and list types. *Reference types and exceptions. *Subtyping. Subsumption and its understanding as inclusion or coercion. *Principles of operational semantics. *Key concepts of semantics: compositionality, adequacy, observational equivalence, full abstraction, and definability."
		},
		{
			"Name" : "Advanced Message-passing Programming",
			"Code" : "INFR11169",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["Message-passing Programming"],
			"Feedback" : [],
            "Summary" : "Modern parallel supercomputers are predominantly programmed using the Message-Passing Interface (MPI) library. Learning the basic MPI syntax and writing medium-scale programs is relatively straightforward, but many issues only arise when tackling large-scale problems on thousands of processes. Typical issues include deadlock, poor scalability or inefficient file IO.There are two basic ways to address these issues. The fundamental MPI calls can be used in more sophisticated ways, which requires an in-depth understanding of the finer details of the MPI standard and its implementation in real libraries. Alternatively, different approaches can be used which employ advanced MPI functionality or which exploit the shared-memory nature of modern multicore compute nodes. Before any correctness or performance issues can be addressed they must first be diagnosed, so knowledge of parallel profiling and debugging is essential.",
            "Course Description" : "The course will cover the following topics: - Scalability challenges for parallel programs - MPI Internals - Parallel profiling and debugging - Message-passing optimisations - Advanced communicator management - Advanced use of MPI collectives - Hybrid message-passing and shared-memory programming - Unstructured meshes - Advanced load-balancing techniques - Parallel file systems and parallel IO"
		},
		{
			"Name" : "Advanced Parallel Techniques",
			"Code" : "INFR11170",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["Threaded Programming", "Message-passing Programming"],
			"Feedback" : [],
            "Summary" : "The majority of current HPC applications are parallelised using a combination of message-passing (the MPI library) or threading (OpenMP directives). As HPC systems grow in size and complexity, other software approaches are now being used to aid performance portability, scalability and maintainability. This course will cover a range of more advanced and upcoming technologies for parallel computing. Key paradigms include: - programming of accelerators including graphics processing units (GPUs); - threading approaches other than OpenMP; - partitioned global address space (PGAS) approaches; - programming languages important in HPC; and, - understanding how to select the appropriate techniques given the problem and hardware at hand.",
            "Course Description" : "Example of topics that will be covered include: Languages: modern C++, Python (and interfacing with compiled code) Threading: pthreads, C++ & boost threads, Intel TBB Accelerators/GPUs: CUDA, OpenCL, OpenMP target directives, OpenACC PGAS: Fortran coarrays, OpenSHMEM, MPI single sided"
		},
		{
			"Name" : "Advanced Topics in Foundations of Databases",
			"Code" : "INFR11122",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Data Science",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "The course focuses on three central aspects of big data: Volume, Variety and Veracity. It will cover tractability and parallel scalability of querying big data (volume), data models and data interoperability (variety), and foundations of data quality and uncertainty (veracity). It aims to expose students to current research and development in connection with big data theory, and prepare them for conducting research in this emerging area. The course content is dynamic and continuously updated to cover the state-of-the-art in big data theory.",
            "Course Description" : "* Background: Fundamental challenges introduced by querying big data; the need for revising the classical computational complexity theory in the context of big data; modelling computational costs and communication costs; BD-tractability: the tractability of queries on big data; the challenges to query data residing in multiple sources; the need to study data quality, the other side of big data. * Volume: (1) the feasibility of computing exact query answers in big data within our available resources: parallel scalability, scale independence, techniques for making big data small; (2) approximate query answering: (a) query-driven approximation, envelopes with absolute approximation bounds, (b) data-driven approximation, synopsis-based approximate query answering, and (c) resource-bounded approximate query answering and anytime approximation. * Variety: data can be in different formats, and come from different sources and/or applications. We shall cover: (a) popular data models, including relational, XML, and graph models, and languages for them, and (b) handling queries over data residing in multiple sources, focusing on both virtual and materialized integration, and efficient query answering. * Veracity: big data = data quantity + data quality; (1) central issues of data quality: data consistency, data accuracy, information completeness, data currency (timeliness), entity resolution; (2) improving data quality: consistency query answering, data repairing, certain fixes; (3) knowledge bases as master data, deducing the true values of entities; (4) handling poor quality information, understanding current technologies and their deficiencies, correctness guarantees. Big data is the next frontier for innovation, competition and productivity. This course will cover fundamental issues in connection with three of four big V's in the typical characterization of big data, namely, Volume, Variety and Veracity."
        },
        {
			"Name" : "Advanced Vision",
			"Code" : "INFR11031",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This module aims to build on the introductory computer vision material taught in Introduction to Vision and Robotics. The main aim is to give students an understanding of main concepts in visual processing by constructing several vision systems during the course of the lecture series and practicals.",
            "Course Description" : "In the course of constructing six vision systems, students will learn about: image noise reduction, region growing, boundary segmentation, Canny edge detector, Hough transform, RANSAC, 2D and 3D coordinate systems, interpretation tree matching, rigid 2D object modeling, 2D position estimation, point distribution models, 3D range sensors, range data segmentation, 3D position estimation, stereo sensors, motion tracking and various approaches to object recognition. Students are also introduced to ethical issues that might arise when using image analysis technology. The activities of the module are designed to further develop intellectual skills in the areas of: laboratory, writing (lab reports and short essays), teamwork, critical analysis, programming and laboratory skills. Relevant QAA Computing Curriculum Sections: Computer Vision and Image Processing"
        },
        {
			"Name" : "Advances in Programming Languages",
			"Code" : "INFR11101",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Programming Language",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course surveys recent developments in programming language design and implementation with an emphasis on those developments which are technological advances on the state-of-the-art.",
            "Course Description" : "Students in APL learn about a range of significant issues in programming language design and implementation. Much of the material is presented in lectures on current topics, supported by additional reading and self-study. Students also learn through a practical exercise where they must individually research a chosen programming language innovation. Areas covered include the following. * The aims of language design: correctness, uniformity, practicality * Advanced programming language constructs: overview and motivation * Specific examples of programming language approaches to different problem domains, generally four or five drawn from areas such as: Concurrency, memory management, security, distribution, parallelism, verification, correctness, types, objects, classes, language interworking, polymorphism, generics, naming, and modularity. Relevant QAA Computing Curriculum Sections: Comparative Programming Languages, Compilers and Syntax Directed Tools, Theoretical Computing"
        },
        {
			"Name" : "Algorithmic Foundations of Data Science",
			"Code" : "INFR11156",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Algorithms and Data Structures",
			"Prerequisites" : ["Algorithms and Data Structures"],
			"Feedback" : [],
            "Summary" : "The course aims to introduce algorithmic techniques that form the foundations of processing and analysing massive datasets of various forms. In particular, the course discusses how to pre-process massive datasets, efficiently store massive datasets, design fast algorithms for massive datasets, and analyse the performance of designed algorithms. Through various examples and the coursework, the students will see applications of the topics discussed in class in other areas of computer science, e.g., machine learning, and network science.",
            "Course Description" : "The course is to discuss algorithmic techniques that form the foundations of processing and analysing massive datasets of various forms. Specific techniques covered in the course include effective representation of datasets, extracting useful information from a dataset based on algebraic tools, designing faster algorithms based on sampling and sketching techniques. Students in class will learn these techniques through intuitions, theoretical reasoning, and practical examples. The syllabus includes: High-dimensional spaces Best-fit subspaces and singular value decomposition Spectral algorithms for massive datasets Data streaming algorithms Clustering Graph sparsification"
        },
        {
			"Name" : "Artificial Intelligence, Present and Future",
			"Code" : "INFR11180",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "AI systems now outperform humans on tasks that were once taken to show great intelligence when undertaken by people (for example, playing chess). How far can this go in the future? What are the assumptions behind different approaches to AI? What dangers can there be from AI systems, and how should AI practitioners take these into account? The course gives a quick overview of the background and of contemporary work in symbolic AI, and looks at the relationship between statistical and 2 logical approaches to AI. It also addresses some of the philosophical and ethical issues that arise.",
            "Course Description" : "The course surveys the state of the art in current AI, looking at systems and techniques in various subfields (eg, agents and reasoning; planning, constraints and uncertainty; google search and the semantic web; dialogue and machine translation; varieties of learning). Throughout, relationships between different approaches to AI will be explored, especially the symbolic/sub-symbolic split at the representation level. Philosophical and ethical issues in AI issues will be introduced. Typical topics include: Reasoning agents Logic and inference via Logic Programming Linked data, semantic net and internet search Monte Carlo Tree Search Planning under uncertainty Adversarial search, game playing Probabilistic inference Inductive Logic Programming Natural language processing, approaches to machine translation Approaches to machine learning AI prospects and dangers Ethical and Philosophical issues."
        },
        {
			"Name" : "Bioinformatics 1",
			"Code" : "INFR11160",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "**This course replaces Bioinformatics 1 (INFR11016)** A primary requisite for relevant, and efficient, research in Bioinformatics is that scientists from both fields (biology and informatics) are involved, or consulted. Team work can only be successful if all parties have a basic ground knowledge of the respective other field and, most importantly, that they can communicate with each other. The aims of the course are to help you overcome both of these difficulties in your future careers. The course will cover topics that include core biology concepts that relate to bioinformatics, biological data and their source and structure as well as common tools for their analysis. The course will also involve group-based practical work on using and developing bioinformatics solutions.",
            "Course Description" : "The course will cover the following: Essential Biology * DNA/proteins * Evolution * Chromosomes and Cells * Molecular structures Bioinformatics * Biological sequence analysis and alignment * Bioinformatics resources and databases * Functional genomics * Proteomics and network analysis * a site visit to see bioinformatics research in action Relevant QAA Computing Curriculum Sections: Databases, Developing Technologies"
        },
        {
			"Name" : "Bioinformatics 2",
			"Code" : "INFR11005",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["Bioinformatics 1"],
			"Feedback" : [],
            "Summary" : "Bioinformatics is at the interface between two of the most influential scientific fields. An appreciation of computational and biological sciences, in particular the terminology employed in both fields, is essential for those working at such an interface. In this course, we aim to cover the following: * The concepts of computer science that relate to problems in biological sciences. * Commercial and academic perspectives on bioinformatics. * The impact of bioinformatics on the methodologies used in biological science. * The influence biological science has on computing science.",
            "Course Description" : "The course will cover the following: * Next generation sequencing technologies * Machine learning algorithms for sequence analysis * Computational assembly of genomic sequences * Gene finding * Advanced functional genomics, expression analysis * Industry guest lecture * The future of bioinformatics: proteomics, neuroinformatics, e-science. Relevant QAA Computing Curriculum Sections: Data Structures and Algorithms, Developing Technologies"
        },
        {
			"Name" : "Case Studies in Design Informatics 1",
			"Code" : "INFR11094",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "How would you do it differently? Every time a design decision is made to pursue one course of action, other routes are closed off. The goal is to work in groups to see why specific project design decisions were taken, and to envisage a different service or product that could be built from the same components.",
            "Course Description" : "Students work in groups. In the second part, they are supported by senior students (normally, those who are enrolled in CSDI2), with a member of academic staff as mentor. This course introduces students to real examples in the emerging field of Design Informatics. A key component of the course is the detailed evaluation of and rationale behind multiple current research projects that highlight the limitations of the state of the art, or novel use of the latest theories and technologies. The syllabus divides into two phases. - In the first part of the course, a core case study is introduced via lectures where a product or service is an important deliverable. - In the second part of the course, each group works on its own, new case study, justifies its selection and scoping, produces a prototype and conducts a short experimental study based on that prototype. Wherever possible, case studies are taken from the ongoing or recent research at the University of Edinburgh. The case studies will be underpinned with lectures reviewing relevant theoretical background and classroom activities to ensure students develop required skills. Formative feedback will be through class interaction and self- or peer assessed quizzes."
        },
        {
			"Name" : "Case Studies in Design Informatics 2",
			"Code" : "INFR11095",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["Case Studies in Design Informatics 1"],
			"Feedback" : [],
            "Summary" : "How would you help the next generation of Design Informatics students avoid the mistakes you made? Every time a decision is made to pursue one course of action, other routes are closed off. The goal is to lead a group of fresh thinkers to see why you made particular project design decisions, and to help them map out a different service or product that could be built from the same components.",
            "Course Description" : "This course extends students' engagement with real examples in the emerging field of Design Informatics. A key component of the course is the detailed evaluation and rationale behind several current research projects that highlight the limitations of the state of the art, or novel use of the latest theories and technologies. The primary learning outcome is the development of specialist reflective and leadership skills that can then be exploited in future industrial application or academic research into Design Informatics. The senior students following this course as part of a two-year masters complete a compulsory summer placement, and then work with junior students (normally, who are enrolled in CSDI1). The syllabus divides into three parts. - In Part 1, students complete a summer internship placement and are then debriefed on it in a series of tutorials in the beginning of the year - In Part 2, students support junior students (typically enrolled in CSDI1) in their group case studies. This support can take a variety of forms, from mentoring a group of younger students to providing training and support in specialist techniques. - In Part 3, concurrently to the support provided to junior students, the students are mentored on their final Masters thesis, similar to the Informatics Research Proposal (INFR11137). This mentoring is in addition to the work students do with their supervisors and will cover key skills required to complete a Masters thesis For Parts 1 and 3, a mix of tutorials and lectures are used."
        },
        {
			"Name" : "Computational Cognitive Neuroscience",
			"Code" : "INFR11036",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "In this course we study computational approaches to understanding cognitive processes, using massively parallel networks. We study biologically-inspired learning rules for connectionist networks, and their application in connectionist models of perception, memory and language.",
            "Course Description" : "*Encoding Information in populations of neurons. *Decoding Information from populations of neurons. *Models of Neurons and Networks of Neurons. *Information transmission and Attention. *Models of Learning and Plasticity. *Models of Memory. *Models of Decision Making. *Models of Mental disorders. *The Bayesian Brain. Relevant QAA Computing Curriculum Sections: Artificial Intelligence"
		},
        {
			"Name" : "Computational Complexity",
			"Code" : "INFR11102",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Theory of Computation",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This module studies the problem of classifying computational problems according to their intrinsic difficulty or 'complexity'. We begin by defining a standard computational model, the Turing machine, which is useful for abstracting out complexity aspects of computational problems. We define various complexity resources, such as time, space, non-determinism , randomness and non-uniformity, and learn how to classify computational problems according to their resource requirements. Among other topics, we discuss the central problem of theoretical computer science, the P vs NP problem, and explain its importance using the notions of reductions and completeness.",
            "Course Description" : "* The computational model: Turing machines * NP and NP completeness * Space complexity * Diagonalization * The polynomial hierarchy * Circuits * Randomized computation * Counting complexity Relevant QAA Computing Curriculum Sections: Concurrency and Parallelism, Data Structures and Algorithms, Theoretical Computing"
		},
        {
			"Name" : "Computer Algebra",
			"Code" : "INFR11111",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Theory of Computation",
			"Prerequisites" : ["Discrete Mathematics and Mathematical Reasoning"],
			"Feedback" : [],
            "Summary" : "Computer graphics uses various shapes such as ellipsoids for modelling. Consider the following problem: we are given an ellipsoid, a point from which to view it, and a plane on which the viewed image is to appear. The problem is to find the contour of the image as an equation (a numerical solution is not good enough for many applications). The problem does not involve particularly difficult mathematics, but a solution by hand is very difficult. This is an example of a problem that can be solved fairly easily with a computer algebra system. These systems have a very wide range of applications and are useful both for routine work and research. From a computer science point of view they also give rise to interesting problems in implementation and the design of algorithms. The considerations here are not only theoretical but also pragmatic. The design of efficient algorithms in this area involves various novel techniques. The course addresses the underlying principles and supporting mathematics by considering a few key areas and algorithms. There is also emphasis on developing an intuitive understanding of techniques. There is a two way process in which the desire to solve mathematical problems motivates the design of new algorithms and in turn the process of designing algorithms motivates supporting mathematical material. The course uses the open source computer algebra system Axiom to support coursework and as an example of algorithms in practice.",
            "Course Description" : "* Axiom: general design principles, user facilities, data structures, domains, etc. * Brief comparison of systems. * Algebraic structures: overview, basic concepts and algorithms. * Arbitrary precision operations on integers, rationals, reals, polynomials and rational expressions. * Importance of greatest common divisors and their efficient computation for integers and univariate polynomials (using modular methods). * Multivariate polynomial systems: solution of sets of equations over the complex numbers; construction and use of Groebner bases; relevant algebraic structures and results. * Reliable solution of systems of polynomial equations in one variable; Sturm sequences, continued fractions method. Relevant QAA Computing Curriculum Sections: Data Structures and Algorithms, Simulation and Modelling, Theoretical Computing"
		},
        {
			"Name" : "Computer Programming Skills and Concepts",
			"Code" : "INFR08022",
			"Credits" : "20",
			"Level" : "8",
			"Year" : "1",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course introduces basic skills required to develop computer programs using modern computer systems, assuming little or no previous experience. It also introduces fundamental concepts of program construction in a suitable high-level programming language. The course has a significant practical component requiring students to construct small programs.",
            "Course Description" : "Introduction: Elements of a modern computer system and computing environment. UNIX, its file system and programming utilities. Program design and development: Specification, problem decomposition. Reasoning about and testing programs. Programming in ANSI C: Expressions, types, variables, assignment, conditionals, iteration, arrays, strings, files, functions. Structured programming: Functional and procedural abstraction, headers and libraries, name and scope."
		},
        {
			"Name" : "Data Analytics with High Performance Computing",
			"Code" : "INFR11171",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Data Science",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "Data Analytics, Data Science and Big Data are just a few of the many topical terms in business and academic research, all effectively referring to the manipulation, processing and analysis of data. Fundamentally, these are all concerned with the extraction from data of knowledge that can be used for competitive advantage or to provide scientific insight. In recent years, this area has undergone a revolution in which HPC has been a key driver, as evidenced by the vast clusters that power Google and Amazon as well as the supercomputing tiers analysing the outputs from the Large Hadron Collider. This course provides an overview of data science and the analytical techniques that form its basis as well as exploring how HPC provides the power that has driven their adoption.",
            "Course Description" : "	The course will cover: - Key data analytical techniques such as, classification, optimisation, and unsupervised learning - Key parallel patterns, for implementing analytical techniques - Relevant HPC and data infrastructures - Case studies from academia and business"
		},
        {
			"Name" : "Data Mining and Exploration",
			"Code" : "INFR11007",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Data Science",
			"Prerequisites" : ["Machine Learning and Pattern Recognition"],
			"Feedback" : [],
            "Summary" : "The aim of this course is to discuss modern techniques for analyzing, interpreting, visualizing and exploiting the data that is captured in scientific and commercial environments. The course will develop the ideas taught in various machine learning courses and discuss the issues in applying them to real-world data sets, as well as teaching about other techniques and data-visualization methods. The course will also feature case-study presentations and each student will undertake a mini-project on a real-world dataset.",
            "Course Description" : "The course will consist of two parts, the first part being a series of lectures on what is outlined below. It is anticipated that there will also be one or two guest lectures from data mining practitioners. The second part will consist of student presentations of papers relating to relevant topics. Students will also carry out a practical mini-project on a real-world dataset. For both paper presentations and mini-projects, lists of suggestions will be available, but students may also propose their own, subject to approval from the instructor. * Introduction, overview * Data preprocessing and cleaning, dealing with missing data * Data visualization, exploratory data analysis * Data mining techniques * Predictive modelling techniques (e.g. SVMs) * Performance evaluation (e.g. ROC curves) * Issues relating to large data sets * Application areas, e.g. text mining, collaborative filtering, retrieval-by-content, web mining, bioinformatics data, astronomy data Relevant QAA Computing Curriculum Sections: Artificial Intelligence"
		},
        {
			"Name" : "Decision Making in Robots and Autonomous Agents",
			"Code" : "INFR11090",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : ["Robotics: Science and Systems", "Intelligent Autonomous Robotics"],
			"Feedback" : [],
            "Summary" : "This course is intended as a specialized course on models and techniques for decision making in autonomous robots that must function in rich interactive settings involving interactions with a dynamic environment, and other agents (e.g., people). In the first part of the course, students will learn about formal models of decision making, and computational methods for automating these decisions within robots. In the second part of the course, we will consider issues arising in practical deployments of such autonomous robots, including problems of achieving safety, explainability and trust. Students will be exposed to current thinking on models and algorithmic methods for achieving these attributes in autonomous robots. The content of this course has connections to other courses within our existing curriculum, such as Reinforcement Learning and Algorithmic Game Theory. A noteworthy difference is that RL and AGTA are primarily focussed on broad coverage of algorithmic methods, whereas this course will emphasize issues of modelling, with some focus on problems arising in practical robotics applications.",
            "Course Description" : "The course will cover the following major themes, although specific topics could vary from year to year. I. Motivation a. Problems involving interaction: Strategically rich human-robot interaction; Multi-robot interactions b. How have decisions been modelled in different disciplines: probability theory, machine learning, psychology and cognitive science II. Mathematics of decisions a. The utility maximization framework, Bayesian choice models b. Causality, Causal learning c. Bandit problems, Markov Decision Processes, and associated analysis methods d. Dynamic programming principle, and associated approximation and learning algorithms e. Incomplete information, Game theoretic models and solution concepts III. Computer science of decisions a. Representations for planning - tradeoffs in modelling hierarchy, uncertainty, etc. b. Safety and trust in autonomous systems c. Explainability in AI d. Bounded rationality and cognitive biases Relevant QAA Computing Curriculum Sections: Artificial Intelligence, Intelligent Information Systems Technologies."
		},
        {
			"Name" : "Design and Analysis of Parallel Algorithms",
			"Code" : "INFR11179",
			"Credits" : "11",
			"Level" : "10",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This module introduces theoretical design principles and analysis techniques that enable the creation and evaluation of efficient, scalable and portable algorithms for parallel computers. Concrete examples will span a range of application areas and architectural models seeking wherever possible to exploit commonality through appropriate abstraction.",
            "Course Description" : "Syllabus: Introduction: Conceptual frameworks for parallelism, message passing, shared address space, PRAM. Cost models for parallel algorithms. Cost efficiency and scalability. Inter-model emulation. Simple examples. Problem solving strategies: Embarrassing parallelism, divide & conquer, pipelining, step-by-step parallelisation. Amdahl's Law. Gustafson's law. Useful primitives: Collective communications, reduction, prefix. Algorithms in selected problem areas, for example: Sorting (bitonic mergesort, hyperquicksort). Matrix oriented algorithms (multiplication, solving linear systems). Graph algorithms (spanning trees, single source & all-to-all shortest paths). "
		},
        {
			"Name" : "Discrete Mathematics and Mathematical Reasoning",
			"Code" : "INFR08023",
			"Credits" : "20",
			"Level" : "8",
			"Year" : "2",
			"Average" : "",
			"Area" : "Theory of Computation",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "Discrete mathematics and formal mathematical reasoning.",
            "Course Description" : "1) Foundations (Chapters 1 & 2 of [Rosen]) 2) Basic number systems, and rudimentary algorithms on numbers and matrices (Chapter 3, [Rosen]) 3) Induction and Recursion (Chapter 4 [Rosen]) 4) Basic Counting (Chapter 5 [Rosen]) 5) Graphs (and binary relations): [Chapter 9, and parts of Chapter 8]] 6) Trees: (Chapter 10 [Rosen]) 7) Discrete probability [Chapter 6, plus some supplementary material]"
		},
        {
			"Name" : "Fundamentals of Data Management",
			"Code" : "INFR11176",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Data Science",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "Better and more effective approaches to managing digital research data are becoming increasingly important in computational science and beyond. The scientific data sets that underpin research papers can now occupy many gigabytes of storage, and are increasingly complex and challenging to work with. This course introduces students to the ideas, methods and techniques of modern, digital data management.",
            "Course Description" : "The course will cover: - Why managing research data better matters, and why it's hard - Data management planning: a required part of twenty first century research - Data formats: structuring data and keeping them useful - Relational and NoSQL databases - Metadata: describing data and keeping them useful - Publication and citation of research data - Persistence, preservation and provenance of research data - Licensing, copyright and access rights: some things researchers need to know - Important distributed data processing tools and techniques, such as: Spark and MapReduce"
		},
        {
			"Name" : "HPC Architectures",
			"Code" : "INFR11175",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Architecture",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "After taking this course students should have a good understanding (from the practioner's perspective) of the way High Performance Computing (HPC) systems are designed and how this affects both the way they are programmed and the performance of applications.",
            "Course Description" : "The course will cover the following topics: - Basic components of HPC systems: processors, memory, interconnect, storage. - Classification of architectures: SIMD/MIMD, shared vs distributed memory, clusters - System software: OSs, processes, threads, scheduling, batch systems. - Brief history of HPC systems, including Moore's Law. - CPU design: functional units, instructions sets, pipelining, branch prediction, ILP (superscalar, VLIW, SIMD instructions), multithreading. - Caches: operation and design features - Memory: operation and design features, including cache coherency and consistency - Multicore CPUs, including cache and memory hierarchy - GPGPUs: operation and design features - Interconnects: operation and design features - Current HPC architectures Lectures will be followed by tutored practical sessions illustrating the key concepts."
		},
        {
			"Name" : "Image and Vision Computing",
			"Code" : "INFR11140",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "In this course we will learn how images are formed given the objects in the three dimensional world, and the basics of how computer vision inverts this process - computing properties of the world from digital images. We will cover topics including basic image formation, image processing, detection, matching and recognition that allow computers to understand the world based on image content.",
            "Course Description" : "Learning Experience: The course will be delivered in a flipped format, with students watching recorded lectures and reading material, with the lecture functioning as a discussion session.  Content: The course proceeds in five parts from foundational concepts such as image formation, through to low-level image processing operations, before building upon those to develop image representations, and use those representations for higher level tasks such as recognition and detection. The following four parts are roughly two weeks each. Image formation. The basic mathematics and physics of how images are formed based on light reflected by real-world objects. Includes ideal pinhole camera and lens models. Some basic 3D geometry, radiometry and photometry. Low-level image analysis. We will introduce basic algorithms such as convolution and filtering for image processing, and RANSAC for fitting. These will be applied for tasks such as edge detection, and line-fitting. To provide a taste of recognition students will perform shape recognition using Bayes theorem. Image Representations: To support working with more unconstrained realistic images, we next introduce feature representations for both local and global features including color histograms, HOG/SIFT, and descriptor bag of words. High-level image analysis: Building upon these image representations, we discuss the topical tasks of object recognition and sliding window-based object detection. Applications: Finally, we finish up with introduction to some applications including basic video processing (optical flow), and foreground detection."
		},
        {
			"Name" : "Informatics 1 - Cognitive Science",
			"Code" : "INFR08020",
			"Credits" : "20",
			"Level" : "8",
			"Year" : "1",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course is designed as a first introduction to Cognitive Science. It will provide a selective but representative overview of the subject, suitable for all interested students, including students on the Cognitive Science degrees and external students. The aim of the lecturing team is to present a unified view of the field, based on a computational approach to analysing cognition. The material is organized by cognitive function (e.g., language, vision), rather than by subdiscipline (e.g., psychology, neuroscience). The course covers language, vision and attention, memory, motor control and action, and reasoning and generalization. All topics will be presented from a computational point of view, and this perspective will be reinforced by lab sessions in which students implement simple cognitive models. The course will also provide a basic grounding in the methods of Cognitive Science, focusing on computational modelling and experimental design.",
            "Course Description" : "Course Description The syllabus covers the following topics. They are listed separately here, but in some cases they will be presented in an interleaved fashion: 1. Language - the language faculty - models of linguistic data, words and rules theory - Connectionist models of language - language acquisition: speech segmentation, word learning, learning syntactic categories - categorization and models of word meaning - understanding sentences 2. Vision - the anatomy of vision, neural correlates of visual perception - Marr's model  - fine vs. coarse coding - face recognition - reading 3. Memory and Attention - types of memory, memory impairments, models of memory - attention, neglect 4. Cognition and neuroscience - an introduction to cognitive neuroscience - some philosophical perspectives on the brain 5. Reasoning and generalization - inductive reasoning - fallacies and (ir)rationality - models of abstraction and generalisation - theory formation and the origins of knowledge Note that this course is intended to give a high-level introduction to the topics listed; subsequent courses (e.g., Computational Cognitive Science) will then provide a more detailed coverage."
		},
        {
			"Name" : "Informatics 1 - Data and Analysis",
			"Code" : "INFR08015",
			"Credits" : "10",
			"Level" : "8",
			"Year" : "1",
			"Average" : "",
			"Area" : "Data Science",
			"Prerequisites" : ["Informatics 1 - Computation and Logic", "Informatics 1 - Functional Programming"],
			"Feedback" : [],
            "Summary" : "An introduction to collecting, representing and interpreting data across the range of informatics. Students will learn the different perspectives from which data is used, the different terminology used when referring to them and a number of representation and manipulation methods. The course will present a small number of running, illustrative examples from the perspectives of hypothesis testing and query formation and answering.",
            "Course Description" : "Structured data and relational databases. Semistructured data and XML. Text corpora. Unstructured data and its analysis. Relevant QAA Computing Curriculum Sections: to be confirmed"
		},
        {
			"Name" : "Informatics 1 - Introduction to Computation",
			"Code" : "INFR08025",
			"Credits" : "20",
			"Level" : "8",
			"Year" : "1",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "**This 20 credit course replaces the two 10 credit courses - 'Informatics 1 - Functional Programming INFR08013' and 'Informatics 1 - Computation and Logic INFR08012' from 2018/19**. An introduction to concepts of programming, using a functional programming language, and to concepts of computation and specification using finite-state systems and propositional logic. These provide examples of the logical ideas of syntax and semantics and the computational ideas of structure and behaviour. Students learn to specify, model and solve small-scale problems succinctly and at an abstract level.",
            "Course Description" : "An introduction to concepts of programming, using the Haskell functional programming language, and to concepts of computation and specification, using finite-state machines and propositional logic. The use of sets, functions and relations to describe models of logic and computation. Programming using functions and data structures including lists and trees; case analysis, recursion and higher-order functions. Finite-state machines as a basic model of computation: deterministic and non-deterministic automata; regular expressions; acceptors; structured design of finite state machines. Propositional logic: truth tables; satisfiability; deduction. Applications from different areas will be used to illustrate and motivate the material."
		},
        {
			"Name" : "Informatics 1 - Object-Oriented Programming",
			"Code" : "INFR08014",
			"Credits" : "10",
			"Level" : "8",
			"Year" : "1",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["Informatics 1 - Computation and Logic", "Informatics 1 - Functional Programming"],
			"Feedback" : [],
            "Summary" : "This course presents a conceptual and practical introduction to object oriented programming, exemplified by Java. As well as providing a grounding in the use of Java, the course will cover general principles of programming in imperative and object oriented frameworks. After completing the course successfully, students will be able to develop programs that support experimentation, simulation and exploration in other parts of the Informatics curriculum (e.g. the capacity to implement, test and observe a particular algorithm).",
            "Course Description" : "An introduction to the concepts of programming using a object oriented programming language. Relevant QAA Computing Curriculum Sections: to be confirmed"
		},
        {
			"Name" : "Informatics 2A - Processing Formal and Natural Languages",
			"Code" : "INFR08008",
			"Credits" : "20",
			"Level" : "8",
			"Year" : "2",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["Informatics 1 - Computation and Logic", "Informatics 1 - Functional Programming", "Informatics 1 - Data and Analysis", "Informatics 1 - Object-Oriented Programming"],
			"Feedback" : [],
            "Summary" : "This course is about processing natural and artificial languages, building on material covered in Informatics 1 concerning finite state machines and regular expressions. This course will consider how the same models of language can be used to describe and analyse both formal languages (such as programming languages) and natural languages (text and speech). It will include material on formal languages and grammars, probabilistic grammars (including hidden Markov models), semantic analysis and human language processing. Examples will be drawn from computer languages and natural language.",
            "Course Description" : "* Grammars and the Chomsky Hierarchy * Regular languages, Finite state automata (FSA), probabilistic FSAs * Context-free languages and Push-down automata * Ambiguity and solutions to the problem * Deterministic parsers * Chart parsers * Probabilistic context-free grammars * Modelling semantics * Context-sensitive languages * Turing machines and computability * Models of human language processing * Overview of language technology Relevant QAA Computing Curriculum Sections: Natural Language Computing; Theoretical Computing; Compilers and Syntax Directed Tools"
		},
        {
			"Name" : "Informatics 2B - Algorithms, Data Structures, Learning",
			"Code" : "INFR08009",
			"Credits" : "20",
			"Level" : "8",
			"Year" : "2",
			"Average" : "",
			"Area" : "Algorithms and Data Structures",
			"Prerequisites" : ["Informatics 1 - Computation and Logic", "Informatics 1 - Functional Programming", "Informatics 1 - Object-Oriented Programming"],
			"Feedback" : [],
            "Summary" : "This course presents key symbolic and numerical data structures and algorithms for manipulating them. Introductory numerical and symbolic learning methods provide a context for the algorithms and data structures. To make the presented ideas concrete, the module will extend the student's skills in Java and Matlab. Examples will be taken from all areas of Informatics.",
            "Course Description" : "Algorithms and Data Structures: * Asymptotic notation and algorithms * Sequential data structures * Searching - including Hashing, AVL Trees, Heaps * Sorting - including Mergesort, Heapsort, Quicksort * Web-scale algorithms * Graphs Learning: * Statistical pattern recognition and machine learning * Multidimensional data * Discrete data and naive Bayes * Modelling and describing continuous data: nearest neighbours and clustering * Gaussians and linear discriminants * Single- and multi-layer networks Relevant QAA Computing Curriculum Sections: Data Structures and Algorithms, Artificial Intelligence"
		},
        {
			"Name" : "Informatics 2C - Introduction to Computer Systems",
			"Code" : "INFR08018",
			"Credits" : "10",
			"Level" : "8",
			"Year" : "2",
			"Average" : "",
			"Area" : "Architecture",
			"Prerequisites" : ["Informatics 1 - Computation and Logic", "Informatics 1 - Functional Programming", "Informatics 1 - Object-Oriented Programming"],
			"Feedback" : [],
            "Summary" : "This course is concerned with the design, implementation and engineering of digital computer systems. It offers an introduction to the internal structure of digital computers.",
            "Course Description" : "The primary aim of the course is to convey an understanding of the internal structure and implementation of digital computers. To impart this knowledge, we first explain how the interface between hardware and software is typically constructed. This interface consists of several key components: * The binary representation and manipulation of atomic data. * The structure of a typical instruction set. * The environment in which a program executes, and the notion of processes and virtual memory. In addition to explaining the interface between hardware and software, this course introduces the ideas behind the hardware implementation of a processor. This consists of several further components: * Combinational logic - how simple stateless building blocks such as adders, multiplexers and decoders can be constructed from logic elements. * Sequential logic - how components with state, such as latches, registers, register files and memories can be constructed from logic elements. * Processor structure - how a simple instruction set can be implemented using combinational and sequential logic components. This material is prefaced by a brief introduction to the C programming language, which is widely used as a systems programming language."
		},
        {
			"Name" : "Informatics 2C - Introduction to Software Engineering",
			"Code" : "INFR08019",
			"Credits" : "10",
			"Level" : "8",
			"Year" : "2",
			"Average" : "",
			"Area" : "Software Engineering",
			"Prerequisites" : ["Informatics 1 - Computation and Logic", "Informatics 1 - Functional Programming", "Informatics 1 - Object-Oriented Programming"],
			"Feedback" : [],
            "Summary" : "This course gives an overview of the engineering of software systems. It introduces the main activities and concerns of industrial and commercial software engineering, and enables students to go beyond programming towards software engineering in their own work.",
            "Course Description" : "The aim is to understand and execute the process of building software systems. The process will entail capturing requirements as use-cases, modelling the system using class and sequence diagrams, implementing the system using Java and running requirements-based tests and system level tests. Beyond the construction process itself, some important surrounding concerns are introduced including: satisfying non-functional requirements, building good human interfaces, and considering various software licensing models. The core topics covered, all at introductory level, in this course are: * Software engineering as a discipline: history, professionalism, ethics * Software engineering activities: requirements capture; design; implementation; testing, debugging and maintenance; software process management. * Modelling in UML (use cases, class diagrams, sequence diagrams). * Design principles and their influence on maintainability of software. * Software configuration management. * Verification, validation and testing. * Software usability and HCI issues. * Economic and social aspects of software ownership, patents and licensing. * Software quality assurance. Some further topics will also be covered, depending on topicality and lecturer's expertise. These might include, for example: * Model-driven development: how to use UML for construction, not just description, of systems * Software in the world: embedded systems, web services, cloud computing, autonomous computing and other means of delivering functionality * Agile software development."
		},
        {
			"Name" : "Informatics 2D - Reasoning and Agents",
			"Code" : "INFR08010",
			"Credits" : "20",
			"Level" : "8",
			"Year" : "2",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : ["Informatics 1 - Computation and Logic", "Informatics 1 - Functional Programming", "Informatics 1 - Object-Oriented Programming"],
			"Feedback" : [],
            "Summary" : "This course focuses on approaches relating to representation, reasoning and planning for solving real world inference. The course illustrates the importance of (i) using a smart representation of knowledge such that it is conducive to efficient reasoning, and (ii) the need for exploiting task constraints for intelligent search and planning. The notion of representing action, space and time is formalized in the context of agents capable of sensing the environment and taking actions that affect the current state. There is also a strong emphasis on the ability to deal with uncertain data in real world scenarios and hence, the planning and reasoning methods are extended to include inference in probabilistic domains.",
            "Course Description" : "1. Intelligent Agents: Introduction * Nature of agents, performance measures and environments * Wumpus World Problem : An example thread (Programming environment setup 2. Search based Planning * Planning as a Search Problem: In deterministic, observable, static and known environments * Smart Searching 1: Using constraints * Smart Searching 2: Exploiting subproblems/Memoisation * Informed Search and Exploration for agents 3. Logical Representation and Planning * Propositional Logic Revisited (Shortcomings) * First Order Logic & Encoding facts/rules in FOL * Inference Rules for Propositional & FOL Calculus * Unification and Generalized Modus Ponens * Resolution based Inference and directing search with it * Knowledge representation : Using FOL to represent action, space, time -- Wumpus Example * Situation Calculus: Representing time in plans 4. Scaling Planning for Complex Tasks * Representing States, Goals and Actions in STRIPS * Partial Order Planning * Planning and Acting in the Real World  5. Acting in Uncertain (real world) Environments * Representation with Bayes Net * Probabilistic Reasoning in Bayes Net * Planning under Uncertainity : Wumpus world revisited * Probabilistic Reasoning over Time I: hidden markov models * Probabilistic Reasoning over Time II: dynamic Bayesian networks * Markov Decision Processes Relevant QAA Computing Curriculum Sections: Artificial Intelligence, Human-Computer Interaction (HCI), Intelligent Information Systems Technologies, Simulation and Modelling"
		},
        {
			"Name" : "Informatics Large Practical",
			"Code" : "INFR09051",
			"Credits" : "20",
			"Level" : "9",
			"Year" : "3",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "**This course replaces AI Large Practical (INFR09043), Software Engineering Large Practical (INFR09045) and Computer Science Large Practical (INFR09044).** The Informatics Large Practical exposes students to the problems that arise with the design and implementation of large-scale software systems, and to methods of coping with such problems. Students will gain experience in how to: - Schedule their work load - Design clearly and coherently structured systems - Discover and use relevant technical information - Implement a large-scale software system - Design and run experiments and tests - Analyse and report results - Present their work in a clear and concise way.",
            "Course Description" : "The Informatics Large Practical gives students experience in developing a non-trivial software system and reporting on the end product. In this way, the practical provides an introduction to the issues and requirements of the more demanding fourth-year project. In particular, the student gains practical experience of: - Reading technical material and identifying the important content - Identifying and formalising project requirements - Identifying computational problems and inventing algorithmic solutions - Constructing a detailed design which does not over-commit to implementation detail - Implementing and testing a software application which realises the design - Experimenting with the implementation to explore the solutions to the computational problems - Writing a report which documents the solutions and the implementation - Managing a software project using a source-code repository."
		},
        {
			"Name" : "Informatics Project Proposal",
			"Code" : "INFR11147",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "The aim of this course is to develop generic research and/or practical skills that can be deployed in academic or commercial environments. Students will demonstrate their ability to develop interesting concepts and/or hypotheses into proposals appropriate for a larger research- or implementation-based project and demonstrate their ability to identify legal, social, ethical and professional issues.",
            "Course Description" : "Structure and delivery of this course will vary according to the nature of the project, and will be agreed between student and supervisor at the start of the semester. Representative activities might include literature review, data preparation, preliminary implementation, or establishing connections and gathering requirements from stakeholders. The student will then produce a project proposal that explains the hypotheses and/or goals, project management, and milestones with approximate times with some justification for these decisions. Key methodologies should be introduced. This 10 credit course replaces Informatics Research Proposal (Level 11) (INFR11137) and Informatics Research Proposal (Level 11) (INFR11071) - 20 credit course."
		},
        {
			"Name" : "Informatics Research Review",
			"Code" : "INFR11136",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course provides students with the opportunity to explore an area of interest in more depth than allowed in a standard taught course. For MSc students this is expected to take the form of reviews of the literature in topics related to their specialism. This 10 credit course replaces Informatics Research Review (Level 11) (INFR11034) - 20 credit course.",
            "Course Description" : "Students and tutors will be matched up based on interests/specialisms at the start of semester 1. Students will be given examples of good reviews, guidance on literature reviewing, literature searching and citation methods. In addition they may be directed towards research seminars in relevant topics. The student should then explore the general area over the semester in consultation with their tutor. It is expected that each student will submit two minor reviews that critically evaluate a single research paper or seminar presentation during the first half of the semester. During the latter half of the semester, students will produce a substantial review of a research area."
		
		},
        {
			"Name" : "Internet of Things Systems, Security, and the Cloud (IoTSSC)",
			"Code" : "INFR11146",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Internet of Things",
			"Prerequisites" : ["Operating Systems"],
			"Feedback" : [],
            "Summary" : "IoTSSC will teach students fundamentals concepts of Internet of Things (IoT) systems, wireless communication paradigms employed in IoT, security and privacy issues, and cloud integration. The course will involve a major coursework that will require students to work in pairs to design, build, and evaluate a practical IoT system. Students will be required to demonstrate their prototypes and present orally their projects at the end of the course, and document their designs and results in a workshop style research paper.",
            "Course Description" : "The course will cover IoT systems architecture, hardware platforms, relevant wireless technologies and networking protocols, security and privacy concepts, device programming and debugging, cloud integration, simple data analytics, and commercialisation challenges. The students should expect to be able to apply the taught concepts in the development of an IoT prototype."
		},
        {
			"Name" : "Introduction to Java Programming",
			"Code" : "INFR09021",
			"Credits" : "10",
			"Level" : "9",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This module is intended for students who have some previous programming experience, but would like to develop their ability to write complete, practical applications. Students with no programming experience should be able to complete the course, although this will almost certainly be challenging and will require additional time. The course uses an object-oriented approach, based around the Java language, but no previous experience of specific languages or technologies is assumed.",
            "Course Description" : "Learning to program requires practice, and students on this course typically have very diverse programming backgrounds. Locating and working with online materials is also an essential skill for developing real applications. For these reasons, the course has no regular lectures on the content - it is facilitated by structured assignments, a recommended textbook, online materials, well-supported lab sessions (or online tutorials for distance learning students), and an online forum. This provides a flexible learning environment, and students should be prepared to manage their own schedule and to take advantage of the resources in a way which is most appropriate to their own experience. The course content includes the following topics: - Object-oriented design - classes, objects, inheritance, coupling, cohesion, responsibility. - The basics of the Java programming language. - The use of external libraries - collections, graphical interfaces, networking. - Development tools. - Code readability and documentation. - Graphical user interfaces. Relevant QAA Computing Curriculum Sections: Programming Fundamentals."
		},
        {
			"Name" : "Introduction to Research in Data Science",
			"Code" : "INFR11138",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Data Science",
			"Prerequisites" : [],
            "Feedback" : [],
            "Summary" : "This course provides students with an overview of current research topics in data science. This overview is provided by guest lectures from researchers working throughout different areas of data science, including databases, machine learning, maths, natural language processing, computer vision, speech processing, and related areas. Second, this course also features a small project to provide students with experience in applying data science methods. The goal of the project is to apply an existing data science method to a interesting real or realistic problem. The student will produce a short project report and poster presentation based on the project.",
            "Course Description" : "This course provides students with an overview of current research topics in data science. This overview is provided by guest lectures from researchers working throughout different areas of data science, including databases, machine learning, maths, natural language processing, computer vision, speech processing, and related areas. Second, this course also features a small project to provide students with experience in applying data science methods. The goal of the project is to apply an existing data science method to a interesting real or realistic problem. The student will produce a short project report and poster presentation based on the project."
		},
        {
			"Name" : "Message-passing Programming",
			"Code" : "INFR11163",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "Parallel programming by definition involves co-operation between processors to solve a common problem. The programmer has to define the tasks that will be executed by the processors, and also how these tasks exchange data and synchronise with each other. In the message-passing model the tasks are separate processes that communicate by explicitly sending each other messages. All parallel operations are performed via calls to some message-passing interface that is entirely responsible for interfacing with the physical communication network. This course uses the de facto standard for message passing, the Message Passing Interface (MPI), which is a library callable from C, C++ or Fortran. Parallel programs written using MPI can run on almost any system from a multicore laptop up to the largest supercomputers in the world.",
            "Course Description" : "The course will cover the following topics: - The message-passing model - Message-passing parallelisation of a regular domain code - MPI terminology - The anatomy of send and receive (synchronous and asynchronous) - Point-to-point message-passing examples - Non-blocking operations - Collectives - Communicator management - Derived datatypes (focusing mainly on array subsections) - Practicalities / Hints and Tips"
		},
        {
			"Name" : "Music Informatics",
			"Code" : "INFR11079",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "The course covers the principal theories, techniques and algorithms developed recently to give computational accounts of how musical phenomena can be analysed, generated and mediated with machine support or collaboration. The emphasis is on concepts, rather than tools, but the ideas have wide applicability. The state of the art is presented in selected areas.",
            "Course Description" : "Background * Physics of music vs musical perception, * Music Representation Basic parameters Basic Local Analysis Algorithms * Beat tracking; score following * Tonal centre (Longuet-Higgins, Bolzano) Musical Grammars Musical Similarity Information Theory, Statistical methods * Characterising musical style * Music generated by statistical constraints (Xenakis) Machine Composition in a Given Style Musical Agents and Interaction Relevant QAA Computing Curriculum Sections: Not yet available"
		},
        {
			"Name" : "Natural Computing",
			"Code" : "INFR11161",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This module teaches you about bio-inspired algorithms for optimisation and search problems. The algorithms are based on simulated evolution (including Genetic algorithms and Genetic programming), particle swarm optimisation, ant colony optimisation as well as systems made of membranes or biochemical reactions among molecules. These techniques are useful for searching very large spaces. For example, they can be used to search large parameter spaces in engineering design and spaces of possible schedules in scheduling. However, they can also be used to search for rules and rule sets, for data mining, for good feed-forward or recurrent neural nets and so on. The idea of evolving, rather than designing, algorithms and controllers is especially appealing in AI. In a similar way it is tempting to use the intrinsic dynamics of real systems consisting e.g. of quadrillions of molecules to perform computations for us. The course includes technical discussions about the applicability and a number of practical applications of the algorithms. In this module, students will learn about - The practicalities of natural computing methods: How to design algorithms for particular classes of problems. - Some of the underlying theory: How such algorithms work and what is provable about them. - Issues of experimental design: How to decide whether an metaheuristic algorithm works well. - Current commercial applications. - Current research directions.",
            "Course Description" : "- Computational aspects of animal behaviour and of biological, chemical or physical systems. - The basics of Genetic Algorithms: selection, recombination and mutation, fitness and objective functions - Variants of GAs: different types of crossover and mutation, of selection and replacement. Inversion and other operators, crowding, niching, island and cellular models - Theory: the schema theorem and its flaws; selection takeover times; statistical mechanics approaches as a theoretical basis for studying GA issues - Hybrid algorithms, memetic algorithms - Pareto optimisation - Ant Colony Optimisation: Basic method for the travelling salesperson problem, local search, application to bin packing, tuning, convergence issues and complexity. - Swarm intelligence, particle swarms, differential evolution. - Greedy randomized adaptive search procedure - DNA computing, molecular computing, membrane computing. - Applications such as engineering optimisation; scheduling and timetabling; data-mining; neural net design. - Comparisons among metaheuristic algorithms, no-free-lunch theorems - Experimental issues: design and analysis of sets of experiments. Relevant QAA Computing Curriculum Sections: Artificial Intelligence, Data Structures and Algorithms, Simulation and Modelling"
		},  
        {
			"Name" : "Natural Language Understanding, Generation, and Machine Translation",
			"Code" : "INFR11157",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : ["Foundations of Natural Language Processing", "Informatics 2A - Processing Formal and Natural Languages", " Accelerated Natural Language Processing"],
			"Feedback" : [],
            "Summary" : "This course explores current research on processing natural language: interpreting, generating, and translating. The course will focus mainly on deep learning approaches to various NLP tasks and applications. It will provide an introduction to the main neural network architectures used in NLP and how they are used for tasks such as syntactic and semantic parsing, as well as end-user applications such as machine translation and text summarization. Building on linguistic and algorithmic knowledge taught in prerequisite courses, this course also aims to further develop students' understanding of the strengths and weaknesses of current approaches with respect to linguistic and computational considerations. Practical assignments will provide the opportunity to implement and analyse some of the approaches considered.",
            "Course Description" : "The course aims to familiarize students with recent research across a range of topics within NLP, mainly within the framework of neural network models, and with a focus on applications such as machine translation, summarisation, and semantic parsing. As an MSc-level course that assumes previous experience with NLP, it will discuss a range of different issues, including linguistic/representational capacity, computational efficiency, optimization, etc. There is no textbook for the course; readings will come from recent research literature."
		},
        {
			"Name" : "Neural Computation",
			"Code" : "INFR11162",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "How the brain computes and processes information from the outside world. How the brain wires up and how it stores information. We will study the brain at a fairly low level, so that we can make contact with neurophysiological data. We will show the necessary biological data and how it can be described in mathematical terms. We will present modelling methods applicable to various levels of organisation of the nervous system (e.g. single cells, networks of cells). We discuss models of particular brain subsystems. In the practical session we use Matlab and NEURON to simulate the models (No familiarity with NEURON required, some self study of Matlab is beneficial.)",
            "Course Description" : "*Introduction and overview of the brain *The neuron *Biophysical and reduced models of neurons *Synapses *Computation and coding in the brain *Networks of neurons *Early and higher visual processing *Network-level modelling *Plasticity and learning Relevant QAA Computing Curriculum Sections: Simulation and Modelling, Artificial intelligence"
		},
        {
			"Name" : "Neural Information Processing",
			"Code" : "INFR11035",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course builds one recent insights that in many cases the computation done by the nervous system can be described in machine learning terms and using information theory. This course focusses on the more mathematical models of the brain and sensory processing. The solutions found by the nervous system might transfer to engineering applications such as compression, parallel processing, and dealing with complex data.",
            "Course Description" : "*Neural coding: reverse correlation, higher order kernels, stimulus reconstruction. Application to the fly visual system. *Information theory as applied to neural coding: mutual information measures, whitening. Application to retinal and LGN coding. *Networks based on information-theoretic cost functions: Helmholtz machine, Linsker's info-max principle. Application to V1 coding. *Independent Component Analysis. Basics, variants of ICA, ICA as model for visual cortex. *Predictive Coding: Kalman filters. Application to cortical coding *Bayesian approaches: Stimulus estimation, probabilistic interpretation of populations codes. Relevant QAA Computing Curriculum Sections: Simulation and Modelling, Artificial intelligence"
		},
        {
			"Name" : "Numerical Algorithms for High Performance Computing",
			"Code" : "INFR11174",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Algorithms and Data Structures",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "The development of High Performance Computing (HPC) systems has been largely driven by the requirements of Computational Scientists running large-scale numerical simulations such as global weather forecasting or studying new materials at the atomic scale. This course covers some of the basic numerical algorithms and computational patterns used in HPC and how they are implemented and used in practice, including the use of standard packages and libraries. Where appropriate, reference will be made to parallel implementations. All these algorithms operate on real-valued variables, not integers, so it is important to understand the issues around storing and working with floating-point numbers, including the errors that this can introduce. This is an applied course and running the algorithms in practical situations is a key component.",
            "Course Description" : "- Computational science as the third methodology - Basic numerics, floating-point representation, errors and exceptions - Simple ordinary differential equations - N-body / particle methods - Dense linear algebra, algorithms and libraries - Partial differential equations and boundary value problems - Sparse linear algebra - Initial value problems and implicit methods - Spectral methods - Fast Fourier Transforms (FFTs) and applications - Monte Carlo methods"
		},
        {
			"Name" : "Parallel Design Patterns",
			"Code" : "INFR11168",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["Message-passing Programming"],
			"Feedback" : [],
            "Summary" : "If you were given a serial problem, conceptually, how would you go about splitting it up into many different parts that could run concurrently on the latest supercomputers? The good news is that we don't need to reinvent the wheel. Instead there are many different approaches (called parallel patterns) that have been developed by the community and can be used in a variety of situations. These patterns apply equally well regardless of whether our problem is a computational one or data driven. Understanding and being able to apply these patterns also helps getting to grips with existing parallel codes and optimising poorly performing computation and data codes. Whilst the lectures take a top down approach, focusing on the patterns themselves, the practical tutorials give students the opportunity to explore the concepts by implementing pattern based solutions to problems using common HPC technologies.",
            "Course Description" : "Reusability is a key driver of this module, both reusability of knowledge (the patterns themselves) and parallel codes (via frameworks.) The parallel patterns (known as a pattern language) that we cover are split into two categories. This closest to the problem area (and most abstract) are parallel algorithm strategy patterns and include: - Task Parallelism - Recursive Splitting - Geometric Decomposition - Pipeline - Discrete Event - Actors The other category of patterns is closer to the implementation and drives how the programmer should structure their code and data. These are implementation strategy patterns and include: - Master/Worker - Loop Parallelism - Fork/Join - Shared Data and Queues - Active Messaging Patterns are described on an abstract level and we will also discuss enhancements that can be made to improve performance/scalability but at the cost of code complexity. Implementations of these patterns are explored in depth in the tutorials. This module also covers parallel frameworks and how we might write generic implementations of patterns which can be applied to numerous problems. Design principals of frameworks, along with popular HPC libraries will be explored so that students understand both from a design and also implementation perspective how to write generic parallel code. Programming exercises use C and Fortran, with MPI and OpenMP."
		},
        {
			"Name" : "Performance Modelling",
			"Code" : "INFR11082",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course teaches various aspects of computer-aided modelling for performance evaluation of (stochastic) dynamic systems. The main focus is on stochastic modelling of computer systems and communication networks to assess performance characteristics such as throughput, response time etc.; however other dynamic systems such as manufacturing systems may also be considered. The central concept of the course will be that a model is as an abstract representation of a system which can be used as a tool to derive information about dynamic behaviour of the system. The more detail we invest in the model, the more sophisticated the information we can extract from it. As the course progresses the model will become increasingly detailed; the corresponding solution techniques will similarly become more complex, relying on increasing levels of computer assistance.",
            "Course Description" : "*Modelling and performance evaluation: models as tools; equilibrium and transient behaviour; analytic vs. algorithmic models. Revision of basic probability concepts. *Making use of models: deriving performance measures from an equilibrium distribution; choosing the parameters for a model; measurement and workload modelling; experimentation. *Representing systems directly as analytic models: operational laws such as Little's Law, simple queues and Markov processes; solving equations to find equilibrium behaviour. * Representing systems as algorithmic models: process-oriented and event-oriented simulation, variance reduction and stopping conditions. *High-level modelling languages: the stochastic process algebra PEPA, stochastic Petri nets and networks of queues. Relevant QAA Computing Curriculum Sections: Simulation and Modelling"
		},
        {
			"Name" : "Performance Programming",
			"Code" : "INFR11167",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["HPC Architectures"],
			"Feedback" : [],
            "Summary" : "Application performance is one of the key requirements for HPC applications. However this is one of the more difficult requirements to satisfy: - Issues effecting performance often vary between different hardware and software environments. This requires performance issues to be frequently re-visited as the hardware and software environment changes. - Performance programming requires detailed knowledge of the underlying environment - The design decisions necessary to achieve good performance are often in conflict with other desirable properties of the program.After taking this course students should have a good practical understanding of the general issues and methodologies associated with designing building and refactoring codes to meet performance requirements. In addition they will have an overview of a number of subjects that are important in the understanding of performance on current systems.",
            "Course Description" : "- Overview of performance programming. Methodology, the optimisation cycle. - Designing for performance. Encapsulation as an aid to performance tuning. - Tools for performance programming. Profilers and code instrumentation. - Compilers and compiler optimisation. - Memory hierarchies, Memory structures and associated optimisations. - Performance tuning for shared memory. - Floating point performance. Pipelines, SIMD, vectorisation."
		}, 
        {
			"Name" : "Pervasive Parallelism",
			"Code" : "INFR11108",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "In this course students develop their six page MSc(R) project proposal, while engaging in a sequence of collaborative activities designed to broaden their awareness of the Pervasive Parallelism landscape, developing research critiquing and presentation skills, and building research relationships with other members of the CDT cohort. In the first phase, students will be paired and, working together, will review current research in both their own and their partner's research area. Partners will be allocated to span diverse areas. Pairs will present their findings and critique the reviewed work to the larger group of CDT students, with each student focusing on presentation of the partners material. In the second phase, students will be paired with a new partner. Each student will develop an individual six page document constituting the proposal for their emerging MSc(R) thesis. Once again, they will collaborate during this phase on presentation of the proposal with a fellow student, with each student ultimately giving the other's presentation to the group. Students will develop generic research skills that can be deployed in academic or industrial environments. Students will demonstrate their ability to develop interesting concepts and hypotheses into research proposals. The course is ultimately assessed on the content of the student's own individual research proposal.",
            "Course Description" : ""
		},
        {
			"Name" : "Probabilistic Modelling and Reasoning",
			"Code" : "INFR11134",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "When dealing with real world data, we often need to deal with uncertainty. For example, short segments of a speech signal are ambiguous, and we need to take into account context in order to make sense of an utterance. Probability theory provides a rigorous method for representing and reasoning with uncertain knowledge. The course covers two main areas (i) the process of inference in probabilistic reasoning systems and (ii) learning probabilistic models from data. Its aim is to provide a firm grounding in probabilistic modelling and reasoning, and to give a basis which will allow students to go on to develop their interests in more specific areas, such as data-intensive linguistics, automatic speech recognition, probabilistic expert systems, statistical theories of vision etc.",
            "Course Description" : "The course will cover the most important topics in probabilistic modelling and unsupervised learning, and provide a thorough basis for understanding other extensions developments and applications. *Introduction * Probability - events, discrete variables - joint, conditional probability * Discrete belief networks, inference * Continuous distributions, graphical Gaussian models * Learning: Maximum Likelihood parameter estimation * Decision theory * Hidden variable models - mixture models and the EM algorithm - factor analysis- ICA, non-linear factor analysis* Dynamic hidden variable models - Hidden Markov models - Kalman filters (and extensions) * Undirected graphical models - Markov Random Fields - Boltzmann machines * Information theory - entropy, mutual information - source coding, Kullback-Leibler divergence * Approximate Inference: MCMC, Variational Methods* Bayesian methods for - Inference on parameters - Model comparison"
		},
        {
			"Name" : "Programming Skills",
			"Code" : "INFR11177",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course is designed to help you to produce higher quality code; code that is readable, maintainable, usable, correct and efficient in less time and with less effort. These programming skills are applicable to programs in any language and the course is illustrated with examples from C, Python, Fortran 90, and Java. Areas of specific relevance to parallel high-performance computing, including the use of batch systems, scientific libraries, profilers, and performance analysis, are also covered.",
            "Course Description" : "- Best practices for scientific computing. - Introduction to operating systems, compilers and batch systems. - Writing programs for people, programs that are readable, maintainable, and usable. - Reviewing code to identify bugs and share expertise. - Debugging using code browsers and debuggers. - Managing versions and collaborating using revision control. - Automating common tasks and building programs using a build tool. - Automated regression and unit testing to help ensure and maintain program correctness. - Profiling and performance analysis to identify and improve a program's use of processing and memory resources. - Security, authentication and authorisation concepts. - REST application programming interfaces. - Open source software."
		},
        {
			"Name" : "Project Preparation",
			"Code" : "INFR11173",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course comprises all aspects of the planning for the individual research project and is undertaken by the student in conjunction with the project supervisor(s). The student and supervisor(s) will agree the topic of the project, after which the student will conduct initial reading to refine the scope of the project and to inform the development of a detailed plan for its implementation. The student will deliver awritten report and make an oral presentation that both describe the background to the project and outline the plan for its successful completion.",
            "Course Description" : "This course encompasses the selection and preparation phase for a dissertation project in High Performance Computing or High Performance Computing with Data Science. The precise topics covered will vary depending on the individual project selected. Topics covered: - Report writing - Academic misconduct and how to avoid it - Professional Skills"
		},
        {
			"Name" : "Reinforcement Learning",
			"Code" : "INFR11010",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "Reinforcement learning (RL) refers to a collection of machine learning techniques which solve sequential decision making problems using a process of trial-and-error. It is a core area of research in artificial intelligence and machine learning, and today provides one of the most powerful approaches to solving decision problems. This course covers foundational models and algorithms used in RL, as well as advanced topics such as scalable function approximation using neural network representations and concurrent interactive learning of multiple RL agents.",
            "Course Description" : "* Reinforcement learning framework * Bandit problems and action selection * Dynamic programming * Monte Carlo methods * Temporal difference learning * Planning in RL * Temporal abstraction * Function approximation for generalisation * Actor-critic and gradient-based optimisation * Multi-agent reinforcement learning * Environments with partial observability * Training agents and evaluating performance Relevant QAA Computing Curriculum Sections: Artificial Intelligence, Data Structures and Algorithms, Intelligent Information Systems Technologies, Simulation and Modelling"
		},
        {
			"Name" : "Robot Learning and Sensorimotor Control",
			"Code" : "INFR11186",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course is designed as a follow up to the introductory course on Robotics: Science and Systems and will gear students towards advanced topics in robot control, learning and planning from an optimisation perspective. Control of complex, compliant, multi degree of freedom (DOF) sensorimotor systems like humanoid robots or autonomous vehicles have been pushing the limits of traditional planning and control methods. This course aims at introducing an optimisation approach to the challenges and will take the students through various aspects involved in motor planning, control, estimation, prediction and learning with an emphasis on the computational perspective. We will learn about optimisation and learning tools and methodologies particularly geared towards problems of online real-time predictive planning for robot control. Issues and possible approaches for planning under uncertainty and redundancy, sensorimotor transformations and stochastic optimal control will be discussed. This will be put in context through exposure to topics in underactuated systems, legged locomotion and human motor control, and the use of computational methods in understanding biological sensorimotor mechanisms.",
            "Course Description" : "1. Optimal Control Approaches - Dynamic Programming, LQR, Trajectory Optimization: Direct and Shooting Methods (iLQR, DDP) 2. Adaptive Learning and Control - Predictive Control - Underactuation - Multi-contact modelling and optimization - Constrained Operational Space Control - Hierarchical QP and Stack of task formulation 3. Interaction and Robust Control - Stochastic Optimal Control - LQG - Cartesian Impedance Control - Passivity Methods - Lyapunov Stability - LQR-Trees and Sum-of-Squares Programming 4. Movement Primitives - Rhythmic vs Point to Point Movements - Dynamical Systems and DMPs - Path Integral Methods - Learning by Demonstration 5. Understanding Human Sensorimotor Control - Force Field and Adaptation - Optimal control theory for Explaining Sensorimotor Behaviour - Impedance Control - Human(oid) Locomotion and Stability."
		},
        {
			"Name" : "Robotics: Science and Systems",
			"Code" : "INFR11092",
			"Credits" : "20",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This course will be a Masters degree level introduction to several core areas in robotics: kinematics, dynamics and control; motion planning; state estimation and signal processing, localization and mapping. Lectures on these topics will be complemented by a large practical that exercises knowledge of a cross section of these techniques in the construction of an integrated robot in the lab, motivated by a task such as robot navigation. Also, in addition to lectures on algorithms and lab sessions, we expect that there will be several lecture hours dedicated to discussion of implementation issues - how to go from the equations to code. The aim of the course is to present a unified view of the field, culminating in a practical involving the development of an integrated robotic system that actually embodies key elements of the major algorithmic techniques.",
            "Course Description" : "- Kinematics - forward and inverse - Dynamics - Control - classical and modern control theories - Sensing - proprioception, etc. - Motion planning - basics and sampling based methods - State estimation, localization and mapping - Implementing SLAM; Multi-modal sensor fusion"
		},
        {
			"Name" : "Software Design and Modelling",
			"Code" : "INFR10064",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "",
			"Area" : "Software Engineering",
			"Prerequisites" : ["Informatics 1 - Object-Oriented Programming", "Informatics 2C - Introduction to Software Engineering"],
			"Feedback" : [],
            "Summary" : "This course introduces the design and modelling of software systems using object-oriented techniques. We start by exploring the use of modelling in software development. Students learn to document designs in the Unified Modeling Language, UML, with emphasis on class, sequence and state diagrams and the Object Constraint Language, OCL. We use modern model-driven development tools and discuss their strengths and weaknesses. We study criteria that make one design better than another in context and introduce design principles and patterns that capture good practice. This course replaces INFR10056 - Software Engineering with Objects and Components.",
            "Course Description" : "The course begins by placing design and modelling in the context of the various software engineering processes in widespread use today. Via labs, lectures and self-study using readings, videos and formative exercises, it teaches students to produce (initially straightforward) designs and to document them using UML models, both on paper and with an appropriate tool. We discuss the different affordances of these modes and how models may be used (i) purely informally, (ii) as reviewed documentation for designs, and/or (iii) in model-driven development in which models are formal artefacts and code may be generated from them. The second part of the course focuses on identifying and producing good designs. What principles should a good object-oriented design follow? We learn some common design patterns and their role in development and learning. Finally we turn to practical model-driven development: how can the cost-benefit ratio of modelling be improved, now and potentially in the future? Students will learn about model transformations, both model-to-model and model-to-text (e.g., code generation) and be introduced to current tools supporting these. We discuss the role of domain specific languages and the integration of model driven development with agile processes. Throughout the course, we identify the deficiencies as well as the benefits of the fast-changing state of the art, aiming to equip students to critically evaluate tools and techniques that become available to them in future."
		},
        {
			"Name" : "Software Development",
			"Code" : "INFR11172",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Software Engineering",
			"Prerequisites" : ["Programming Skills "],
			"Feedback" : [],
            "Summary" : " Software development is more than just writing programs and this course provides an introduction to the complete range of software development activities, from gathering requirements through to evaluation of a finished product. The course describes how software development projects are created and managed to achieve the delivery of high-quality, efficient, robust, portable, usable software products. You will be introduced to areas of increasing prominence in both academia and industry including the importance of software sustainability and the rise of agile methods and extreme programming. The course should support in the understanding of the value of practical software development skills to the HPC, computational science and engineering.",
            "Course Description" : "- Software Development Projects and Processes - Development Models - Project Approaches including Agile and PRINCE2 - Project Planning: Task Scheduling and Risks - Design: Requirements Capture and Prioritisation, Interfaces, Code, System - Software Testing  - Usability and Evaluation - Project Teams and Communications - Project Reviews"
		},
        {
			"Name" : "The Human Factor: Working with Users",
			"Code" : "INFR11141",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : [],
			"Feedback" : [],
            "Summary" : "This is an introduction to the fields of Human Factors and User Experience with an emphasis on developing practical skills that are grounded in a strong knowledge of theory.",
            "Course Description" : "\"If the user can't use it, then it doesn't work at all.\" (Susan Dray) When technical systems that have been crafted in years of painstaking work fail in practice, more often than not this is due to a lack of fit between the complex system, the people who interact with it, and the contexts in which it is used. In the best case, failure is just annoying, in the worst case, it costs lives. In this course, we will look at the art and craft of building technical systems that people can actually use successfully. To this end, we will draw on relevant findings from anthropology; behavioural, cognitive and social psychology; human-computer interaction; and sociology. The course will be taught using a flipped classroom - before class, you will work through materials; in class, we will work on activities designed to review the material and deepen your learning."
		},
        {
			"Name" : "Threaded Programming",
			"Code" : "INFR11178",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "5",
			"Average" : "",
			"Area" : "Misc.",
			"Prerequisites" : ["Students are required to be familiar with C or Fortran for practical exercises."],
			"Feedback" : [],
            "Summary" : "This course is a practical introduction to parallel programming using the threading model, which is commonly used on shared memory and multicore hardware. The majority of the course is focused on teaching the use of the industry standard OpenMP API.",
            "Course Description" : "After taking this course students should have a good practical understanding of multithreaded programming and be competent OpenMP programmers. The course will cover the following topics: - Basic concepts of shared memory: threads, tasks, shared/private data, synchronisation. - Concepts of OpenMP: parallel regions, shared/private variables, parallel loops, reductions - OpenMP parallel regions and associated clauses - OpenMP worksharing directives, scheduling of parallel loops - OpenMP synchronisation: barriers, critical sections, atomics, locks. - OpenMP tasks - Additional features of OpenMP: nesting, orphaning, threadprivate globals, OpenMP 4.0 features - OpenMP implementations - Memory models. Lectures will be followed by tutored practical sessions illustrating the key concepts. Students will have the choice of using either C or Fortran in the practical programming sessions on OpenMP."
		},
        {
			"Name" : "Usable Security and Privacy",
			"Code" : "INFR11158",
			"Credits" : "10",
			"Level" : "11",
			"Year" : "4",
			"Average" : "",
			"Area" : "Security",
			"Prerequisites" : [],
            "Feedback" : [],
            "Summary" : "Humans are a vital component of secure and private systems, they are also one of the most expensive components and the most challenging to reason about. In this course, students will learn about how to create systems that are usable while still fulfilling their primary security or privacy mission. Students will also learn about research topics such as designing user studies to critically evaluate interfaces and reading academic papers to create an academically-informed view of the topic.",
            "Course Description" : "- Introduction: History and overview of the Usable Security and Privacy research area including the transition from blaming users to treating them as valued components of a secure system. - Study design: Security and privacy activities tend to be secondary tasks. The student will learn how to design and analyze usability studies that are common in security and privacy such as targeting secondary tasks or using some deception. - Privacy: Basic overview of the definitions of privacy as well as some of the legal and social aspects of it. Analysis of common privacy issues and how they are expressed through user interaction with systems. - Security: Overview of common security technologies and how they are impacted by usability. In- depth look at select topics such as password construction and management. - Ethics: Discussion of ethics, particularly around research in topics in security and privacy where participants can be particularly vulnerable."
		}
	]
}